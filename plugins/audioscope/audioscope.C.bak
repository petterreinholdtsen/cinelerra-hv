
/*
 * CINELERRA
 * Copyright (C) 1997-2011 Adam Williams <broadcast at earthling dot net>
 * 
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 * 
 */

#include "audioscope.h"
#include "bcdisplayinfo.h"
#include "clip.h"
#include "bchash.h"
#include "filexml.h"
#include "language.h"
#include "cicolors.h"
#include "samples.h"
#include "theme.h"
#include "transportque.inc"
#include "units.h"
#include "vframe.h"


#include <string.h>



REGISTER_PLUGIN(AudioScope)


AudioScopeConfig::AudioScopeConfig()
{
	window_size = MAX_WINDOW;
	window_fragment = MAX_FRAGMENT;
	w = 640;
	h = 480;
	history_size = 4;
}

int AudioScopeConfig::equivalent(AudioScopeConfig &that)
{
	return window_size == that.window_size &&
		window_fragment == that.window_fragment &&
		history_size == that.history_size;
}

void AudioScopeConfig::copy_from(AudioScopeConfig &that)
{
	window_size = that.window_size;
	window_fragment = that.window_fragment;
	history_size = that.history_size;
}

void AudioScopeConfig::interpolate(AudioScopeConfig &prev, 
	AudioScopeConfig &next, 
	int64_t prev_frame, 
	int64_t next_frame, 
	int64_t current_frame)
{
	copy_from(prev);

	CLAMP(history_size, MIN_HISTORY, MAX_HISTORY - 1);
}



AudioScopeFrame::AudioScopeFrame(int data_size, int fragment_number)
{
	this->size = data_size;
	this->fragment_number = fragment_number;
	for(int i = 0; i < CHANNELS; i++)
		data[i] = new float[data_size];
	force = 0;
}

AudioScopeFrame::~AudioScopeFrame()
{
	for(int i = 0; i < CHANNELS; i++)
		delete [] data[i];
}







AudioScopeHistory::AudioScopeHistory(AudioScope *plugin,
	int x, 
	int y)
 : BC_IPot(x, 
	y,
	plugin->config.history_size,
	MIN_HISTORY,
	MAX_HISTORY)
{
	this->plugin = plugin;
}

int AudioScopeHistory::handle_event()
{
	plugin->config.history_size = get_value();
	plugin->send_configure_change();
	return 1;
}








AudioScopeWindowSize::AudioScopeWindowSize(AudioScope *plugin, 
	int x, 
	int y,
	char *text)
 : BC_PopupMenu(x, 
	y, 
	80, 
	text)
{
	this->plugin = plugin;
}

int AudioScopeWindowSize::handle_event()
{
	plugin->config.window_size = atoi(get_text());
	plugin->send_configure_change();
	return 1;
}


AudioScopeWindowSizeTumbler::AudioScopeWindowSizeTumbler(AudioScope *plugin, int x, int y)
 : BC_Tumbler(x, 
 	y)
{
	this->plugin = plugin;
}

int AudioScopeWindowSizeTumbler::handle_up_event()
{
	plugin->config.window_size *= 2;
	if(plugin->config.window_size > MAX_WINDOW)
		plugin->config.window_size = MAX_WINDOW;
	char string[BCTEXTLEN];
	sprintf(string, "%d", plugin->config.window_size);
	((AudioScopeWindow*)plugin->get_thread()->get_window())->window_size->set_text(string);
	plugin->send_configure_change();
}

int AudioScopeWindowSizeTumbler::handle_down_event()
{
	plugin->config.window_size /= 2;
	if(plugin->config.window_size < MIN_WINDOW)
		plugin->config.window_size = MIN_WINDOW;
	char string[BCTEXTLEN];
	sprintf(string, "%d", plugin->config.window_size);
	((AudioScopeWindow*)plugin->get_thread()->get_window())->window_size->set_text(string);
	plugin->send_configure_change();
	return 1;
}


AudioScopeFragmentSize::AudioScopeFragmentSize(AudioScope *plugin, 
	int x, 
	int y,
	char *text)
 : BC_PopupMenu(x, 
	y, 
	80, 
	text)
{
	this->plugin = plugin;
}

int AudioScopeFragmentSize::handle_event()
{
	plugin->config.window_fragment = atoi(get_text());
	plugin->send_configure_change();
	return 1;
}


AudioScopeFragmentSizeTumbler::AudioScopeFragmentSizeTumbler(AudioScope *plugin, int x, int y)
 : BC_Tumbler(x, 
 	y)
{
	this->plugin = plugin;
}

int AudioScopeFragmentSizeTumbler::handle_up_event()
{
	plugin->config.window_fragment *= 2;
	if(plugin->config.window_fragment > MAX_FRAGMENT)
		plugin->config.window_fragment = MAX_FRAGMENT;
	char string[BCTEXTLEN];
	sprintf(string, "%d", plugin->config.window_fragment);
	((AudioScopeWindow*)plugin->get_thread()->get_window())->window_fragment->set_text(string);
	plugin->send_configure_change();
}

int AudioScopeFragmentSizeTumbler::handle_down_event()
{
	plugin->config.window_fragment /= 2;
	if(plugin->config.window_fragment < MIN_FRAGMENT)
		plugin->config.window_fragment = MIN_FRAGMENT;
	char string[BCTEXTLEN];
	sprintf(string, "%d", plugin->config.window_fragment);
	((AudioScopeWindow*)plugin->get_thread()->get_window())->window_fragment->set_text(string);
	plugin->send_configure_change();
	return 1;
}











AudioScopeWindow::AudioScopeWindow(AudioScope *plugin)
 : PluginClientWindow(plugin, 
	plugin->config.w, 
	plugin->config.h, 
	640, 
	480,
	1)
{
	this->plugin = plugin;
}

AudioScopeWindow::~AudioScopeWindow()
{
}

void AudioScopeWindow::create_objects()
{
	int x = plugin->get_theme()->widget_border;
	int y = x;
	char string[BCTEXTLEN];

	add_subwindow(canvas = new BC_SubWindow(x, 
		y, 
		get_w() - x - plugin->get_theme()->widget_border, 
		get_h() - plugin->get_theme()->widget_border * 3 - y - BC_Pot::calculate_h(),
		BLACK));
	draw_overlay();

	y += canvas->get_h() + plugin->get_theme()->widget_border;

	sprintf(string, "%d", plugin->config.window_size);
	add_subwindow(window_size_title = new BC_Title(x, y, _("Resolution:")));

	x += window_size_title->get_w() + plugin->get_theme()->widget_border;
	add_subwindow(window_size = new AudioScopeWindowSize(plugin, x, y, string));
	x += window_size->get_w();
	add_subwindow(window_size_tumbler = new AudioScopeWindowSizeTumbler(plugin, x, y));
	
	for(int i = MIN_WINDOW; i <= MAX_WINDOW; i *= 2)
	{
		sprintf(string, "%d", i);
		window_size->add_item(new BC_MenuItem(string));
	}

	x += window_size_tumbler->get_w() + plugin->get_theme()->widget_border;
	sprintf(string, "%d", plugin->config.window_fragment);
	add_subwindow(window_fragment_title = new BC_Title(x, y, _("Zoom X:")));
	x += window_fragment_title->get_w() + plugin->get_theme()->widget_border;
	add_subwindow(window_fragment = new AudioScopeFragmentSize(plugin, x, y, string));
	x += window_fragment->get_w();
	add_subwindow(window_fragment_tumbler = new AudioScopeFragmentSizeTumbler(plugin, x, y));
	x += window_fragment_tumbler->get_w() + plugin->get_theme()->widget_border;


	for(int i = MIN_FRAGMENT; i <= MAX_FRAGMENT; i *= 2)
	{
		sprintf(string, "%d", i);
		window_fragment->add_item(new BC_MenuItem(string));
	}

	add_subwindow(history_size_title = new BC_Title(x, y, _("History Size:")));
	x += history_size_title->get_w() + plugin->get_theme()->widget_border;
	add_subwindow(history_size = new AudioScopeHistory(plugin,
		x, 
		y));


	show_window();
}

int AudioScopeWindow::resize_event(int w, int h)
{
	int x = plugin->get_theme()->widget_border;
	int y = x;

	canvas->reposition_window(x, 
		y, 
		w - x - plugin->get_theme()->widget_border, 
		h - plugin->get_theme()->widget_border * 3 - y - BC_Pot::calculate_h());
	canvas->clear_box(0, 0, canvas->get_w(), canvas->get_h());
	draw_overlay();
// Remove all columns which may be a different size.
	plugin->frame_buffer.remove_all_objects();

	y = canvas->get_y() + canvas->get_h() + 5;
	y += canvas->get_h() + plugin->get_theme()->widget_border;
	
	window_size_title->reposition_window(x, y);
	
	x += window_size_title->get_w() + plugin->get_theme()->widget_border;
	window_size->reposition_window(x, y);
	x += window_size->get_w();
	window_size_tumbler->reposition_window(x, y);
	x += window_size_tumbler->get_w() + plugin->get_theme()->widget_border;
	
	window_fragment_title->reposition_window(x, y);
	x += window_fragment_title->get_w() + plugin->get_theme()->widget_border;
	window_fragment->reposition_window(x, y);
	x += window_fragment->get_w();
	window_fragment_tumbler->reposition_window(x, y);
	x += window_fragment_tumbler->get_w() + plugin->get_theme()->widget_border;
	history_size_title->reposition_window(x, y);
	x += history_size_title->get_w() + plugin->get_theme()->widget_border;
	history_size->reposition_window(x, y);

	plugin->config.w = w;
	plugin->config.h = h;
	return 0;
}

void AudioScopeWindow::draw_overlay()
{
	canvas->set_color(GREEN);
	canvas->draw_line(0, 
		canvas->get_h() / 2, 
		canvas->get_w(), 
		canvas->get_h() / 2);
	canvas->draw_line(canvas->get_w() / 2,
		0,
		canvas->get_w() / 2,
		canvas->get_h());
//printf("AudioScopeWindow::draw_overlay %d\n", __LINE__);
}


void AudioScopeWindow::update_gui()
{
	char string[BCTEXTLEN];
	sprintf(string, "%d", plugin->config.window_size);
	window_size->set_text(string);
	sprintf(string, "%d", plugin->config.window_fragment);
	window_fragment->set_text(string);
}

























AudioScope::AudioScope(PluginServer *server)
 : PluginAClient(server)
{
	reset();
	timer = new Timer;
}

AudioScope::~AudioScope()
{
	delete [] data;
	delete audio_buffer[0];
	delete audio_buffer[1];
	delete timer;
	frame_buffer.remove_all_objects();
	frame_history.remove_all_objects();
}


void AudioScope::reset()
{
	thread = 0;
	data = 0;
	audio_buffer[0] = 0;
	audio_buffer[1] = 0;
	audio_buffer_start = -MAX_WINDOW * 2;
	allocated_data = 0;
	last_fragment = 0;
	total_fragments = 0;
	bzero(&header, sizeof(data_header_t));
}


const char* AudioScope::plugin_title() { return N_("AudioScope"); }
int AudioScope::is_realtime() { return 1; }
int AudioScope::is_multichannel() { return 1; }

int AudioScope::process_buffer(int64_t size, 
		Samples **buffer,
		int64_t start_position,
		int sample_rate)
{
	int channels = MIN(get_total_buffers(), CHANNELS);


	load_configuration();

// Reset audio buffer
	if(window_size != config.window_size)
	{
		render_stop();
		window_size = config.window_size;
	}

// The size of a fragment
	int fragment_size = MIN(config.window_size, config.window_fragment);


	if(!data)
	{
		data = new unsigned char[sizeof(data_header_t)];
		allocated_data = 0;
	}

	if(!audio_buffer[0])
	{
		for(int i = 0; i < CHANNELS; i++)
		{
			audio_buffer[i] = new Samples(MAX_WINDOW);
		}
	}

// Total fragments rendered in this call
	int total_fragments = 0;

// process 1 fragment at a time
	int64_t current_start_position = start_position;
// printf("AudioScope::process_buffer %d %lld %lld\n", 
// __LINE__, 
// start_position,
// audio_buffer_start);
	for(int sample = 0; 
		sample < size; 
		sample += fragment_size)
	{
		int current_fragment_size = fragment_size;
		if(current_fragment_size + sample > size)
			current_fragment_size = size - sample;

// Keep audio buffer full.
// Forward playback.
		if(get_direction() == PLAY_FORWARD &&
			current_start_position >= audio_buffer_start &&
			current_start_position < audio_buffer_start + config.window_size)
		{
			int64_t difference = current_start_position - audio_buffer_start;
			if(difference)
			{
				int64_t old_chunk = config.window_size - difference;
				for(int i = 0; i < channels; i++)
				{
					memcpy(audio_buffer[i]->get_data(), 
						audio_buffer[i]->get_data() + difference,
						old_chunk * sizeof(double));
//printf("AudioScope::process_buffer %d %d\n", __LINE__, current_start_position + old_chunk);
					audio_buffer[i]->set_offset(old_chunk);
					read_samples(audio_buffer[i],
						i,
						get_samplerate(),
						current_start_position + old_chunk,
						difference);
					audio_buffer[i]->set_offset(0);
				}
			}

			for(int i = 0; i < channels; i++)
			{
				memcpy(buffer[i]->get_data() + sample, 
					audio_buffer[i]->get_data(), 
					current_fragment_size * sizeof(double));
			}
			audio_buffer_start = current_start_position;
		}
		else
// Reverse playback.
		if(get_direction() == PLAY_REVERSE &&
			current_start_position <= audio_buffer_start &&
			current_start_position > audio_buffer_start - config.window_size)
		{
// buffer should end at current_start_position + current_fragment_size
			int64_t difference = audio_buffer_start - current_start_position;
			int64_t old_chunk = config.window_size - difference;
			if(difference)
			{
				for(int i = 0; i < channels; i++)
				{
					memcpy(audio_buffer[i]->get_data(),
						audio_buffer[i]->get_data() + difference, 
						old_chunk * sizeof(double));

// printf("AudioScope::process_buffer %d %lld %lld\n", 
// __LINE__, 
// current_start_position - old_chunk,
// difference);
					read_samples(audio_buffer[i],
						i,
						get_samplerate(),
						current_start_position + old_chunk,
						difference);
				}
			}

			for(int i = 0; i < channels; i++)
			{
				memcpy(buffer[i]->get_data() + sample, 
					audio_buffer[i]->get_data(), 
					current_fragment_size * sizeof(double));
			}
			audio_buffer_start = current_start_position;
		}
		else
// New buffer
		if(get_direction() == PLAY_FORWARD)
		{
			for(int i = 0; i < channels; i++)
			{
				read_samples(audio_buffer[i],
					i,
					get_samplerate(),
					current_start_position,
					config.window_size);
				memcpy(buffer[i]->get_data() + sample, 
					audio_buffer[i]->get_data(), 
					current_fragment_size * sizeof(double));
			}
			
			audio_buffer_start = current_start_position;
		}
		else
		{
//printf("AudioScope::process_buffer %d %d\n", __LINE__, current_start_position);
			for(int i = 0; i < channels; i++)
			{
				read_samples(audio_buffer[i],
					i,
					get_samplerate(),
					current_start_position,
					config.window_size);
				memcpy(buffer[i]->get_data() + sample, 
					audio_buffer[i]->get_data(), 
					current_fragment_size * sizeof(double));
			}
			
			audio_buffer_start = current_start_position;
		}
		
// Process the samples

// Append a window to end of GUI buffer
		if(allocated_data < (total_fragments + 1) * config.window_size * CHANNELS)
		{
			int new_allocation = (total_fragments + 1) * 
				config.window_size * 
				CHANNELS;
			unsigned char *new_data = new unsigned char[sizeof(data_header_t) +
				sizeof(float) * new_allocation];
			data_header_t *new_header = (data_header_t*)new_data;
			data_header_t *old_header = (data_header_t*)data;
			memcpy(new_header->samples, 
				old_header->samples, 
				sizeof(float) * allocated_data);
			delete [] data;
			data = new_data;
			allocated_data = new_allocation;
		}

		data_header_t *header = (data_header_t*)data;
		for(int j = 0; j < CHANNELS; j++)
		{
			float *sample_output = header->samples + 
				total_fragments * CHANNELS * config.window_size + 
				config.window_size * j;
			for(int i = 0; i < config.window_size; i++)
			{
				sample_output[i] = audio_buffer[j]->get_data()[i];
			}
		}


		if(get_direction() == PLAY_REVERSE)
			current_start_position -= fragment_size;
		else
			current_start_position += fragment_size;
		total_fragments++;
	}

	data_header_t *header = (data_header_t*)data;
	header->window_size = config.window_size;
	header->window_fragment = config.window_fragment;
	header->sample_rate = sample_rate;
	header->total_fragments = total_fragments;

	send_render_gui(data, 
		sizeof(data_header_t) + 
			sizeof(float) * total_fragments * config.window_size * CHANNELS);

	return 0;
}

void AudioScope::render_stop()
{
	audio_buffer_start = -MAX_WINDOW * 2;
	frame_buffer.remove_all_objects();
}




NEW_WINDOW_MACRO(AudioScope, AudioScopeWindow)

void AudioScope::update_gui()
{
	if(thread)
	{
		int result = load_configuration();
		AudioScopeWindow *window = (AudioScopeWindow*)thread->get_window();
		window->lock_window("AudioScope::update_gui");
		if(result) window->update_gui();

//printf("AudioScope::update_gui %d\n", __LINE__);
// Shift in accumulated frames
		if(frame_buffer.size())
		{
			BC_SubWindow *canvas = window->canvas;
// Frames to draw in this iteration
			int total_frames = timer->get_difference() * 
				header.sample_rate / 
				header.window_fragment / 
				1000 + 1;
// Add forced frame drawing
			for(int i = total_frames; i < frame_buffer.size(); i++)
				if(frame_buffer.get(i)->force) total_frames++;
			total_frames = MIN(frame_buffer.size(), total_frames);
//printf("AudioScope::update_gui %d %d %d\n", __LINE__, total_columns, frame_buffer.size());



// Shift frames into history
			for(int frame = 0; frame < total_frames; frame++)
			{
				if(frame_history.size() >= config.history_size)
					frame_history.remove_object_number(0);
				
				frame_history.append(frame_buffer.get(0));
				frame_buffer.remove_number(0);
			}

// Reduce history size
			while(frame_history.size() > config.history_size)
				frame_history.remove_object_number(0);

// Draw frames from history
			canvas->clear_box(0, 0, canvas->get_w(), canvas->get_h());
			for(int frame = 0; frame < frame_history.size(); frame++)
			{
				AudioScopeFrame *ptr = frame_history.get(frame);
				
				int luma = (frame + 1) * 255 / frame_history.size();
				if(frame == frame_history.size() - 1)
					canvas->set_color(RED);
				else
					canvas->set_color((luma << 16) |
						(luma << 8) |
						luma);
				int x1 = 0;
				int y1 = 0;
				int w = canvas->get_w();
				int h = canvas->get_h();
				float *channel0 = ptr->data[0];
				float *channel1 = ptr->data[1];
				int number = 0;
				for(int point = 0; point < ptr->size; point++)
				{
					int x2 = (int)(channel0[point] * w / 2 + w / 2);
					int y2 = (int)(-channel1[point] * h / 2 + h / 2);
					CLAMP(x2, 0, w - 1);
					CLAMP(y2, 0, h - 1);
					
					if(number)
					{
						canvas->draw_line(x1, y1, x2, y2);
					}
					else
					{
						number++;
					}

					x1 = x2;
					y1 = y2;
				}
			}


// Draw overlay
			window->draw_overlay();
			canvas->flash();
		}


		timer->update();

		while(frame_buffer.size() > MAX_COLUMNS)
			frame_buffer.remove_object_number(0);

		thread->get_window()->unlock_window();
	}
}

void AudioScope::render_gui(void *data, int size)
{
	if(thread)
	{
		thread->get_window()->lock_window("AudioScope::render_gui");
		data_header_t *header = (data_header_t*)data;
		memcpy(&this->header, header, sizeof(data_header_t));
		BC_SubWindow *canvas = ((AudioScopeWindow*)thread->get_window())->canvas;
		int h = canvas->get_h();

// Set all previous frames to draw immediately
		for(int i = 0; i < frame_buffer.size(); i++)
			frame_buffer.get(i)->force = 1;

		for(int current_fragment = 0; 
			current_fragment < header->total_fragments;
			current_fragment++)
		{
			float *in_frame = header->samples + 
				current_fragment * header->window_size * CHANNELS;
			AudioScopeFrame *out_frame = new AudioScopeFrame(
				header->window_size, 
				total_fragments);

// Copy the window to the frame
			for(int j = 0; j < CHANNELS; j++)
			{
				for(int i = 0; i < header->window_size; i++)
				{
					out_frame->data[j][i] = in_frame[header->window_size * j + i];
				}
			}

			frame_buffer.append(out_frame);
			total_fragments++;
		}

		thread->get_window()->unlock_window();
	}
}








LOAD_CONFIGURATION_MACRO(AudioScope, AudioScopeConfig)

void AudioScope::read_data(KeyFrame *keyframe)
{
	FileXML input;
	input.set_shared_string(keyframe->get_data(), strlen(keyframe->get_data()));

	int result = 0;
	while(!result)
	{
		result = input.read_tag();

		if(!result)
		{
			if(input.tag.title_is("AUDIOSCOPE"))
			{
				config.w = input.tag.get_property("W", config.w);
				config.h = input.tag.get_property("H", config.h);
				config.history_size = input.tag.get_property("HISTORY_SIZE", config.history_size);
				config.window_size = input.tag.get_property("WINDOW_SIZE", config.window_size);
				config.window_fragment = input.tag.get_property("WINDOW_FRAGMENT", config.window_fragment);
			}
		}
	}
}

void AudioScope::save_data(KeyFrame *keyframe)
{
	FileXML output;
	output.set_shared_string(keyframe->get_data(), MESSAGESIZE);

	output.tag.set_title("AUDIOSCOPE");
	output.tag.set_property("W", config.w);
	output.tag.set_property("H", config.h);
	output.tag.set_property("HISTORY_SIZE", config.history_size);
	output.tag.set_property("WINDOW_SIZE", (int)config.window_size);
	output.tag.set_property("WINDOW_FRAGMENT", (int)config.window_fragment);
	output.append_tag();
	output.append_newline();
	output.terminate_string();
}





