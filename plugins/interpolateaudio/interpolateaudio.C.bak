#include "bcdisplayinfo.h"
#include "clip.h"
#include "defaults.h"
#include "guicast.h"
#include "filexml.h"
#include "language.h"
#include "mainprogress.h"
#include "pluginaclient.h"

#include <string.h>




class InterpolateAudioConfig
{
public:
	InterpolateAudioConfig();

	void copy_from(InterpolateAudioConfig *config);
	int equivalent(InterpolateAudioConfig *config);

	int enabled;
};


class InterpolateAudioEnable : public BC_CheckBox
{
public:
	InterpolateAudioEnable(InterpolateAudioEffect *plugin,
		int x,
		int y);
	int handle_event();
	InterpolateAudioEffect *plugin;
};

class InterpolateAudioWindow : public BC_Window
{
public:
	InterpolateAudioWindow(InterpolateAudio *plugin, int x, int y);
	~InterpolateAudioWindow();
	void create_objects();
	int close_event();
	InterpolateAudio *plugin;
	InterpolateAudioEnabled *enabled;
};






PLUGIN_THREAD_HEADER(InterpolateAudio, InterpolateAudioThread, InterpolateAudioWindow)



class InterpolateAudioEffect : public PluginAClient
{
public:
	InterpolateAudioEffect(PluginServer *server);
	~InterpolateAudioEffect();

	PLUGIN_CLASS_MEMBERS(InterpolateAudioConfig, InterpolateAudioThread)

	int process_buffer(double *samples,
		int64_t start_position,
		int sample_rate);
	int is_realtime();
	int load_defaults();
	int save_defaults();
	void save_data(KeyFrame *keyframe);
	void read_data(KeyFrame *keyframe);
	void update_gui();

	int64_t range_start;
	int64_t range_end;
	int64_t current_start;
	int64_t current_end;
#define FRAGMENT_SIZE 4096
	double *start_fragment;
	double *end_fragment;
};




REGISTER_PLUGIN(InterpolateAudioEffect)




InterpolateAudioConfig::InterpolateAudioConfig()
{
	enabled = 1;
}

void InterpolateAudioConfig::copy_from(InterpolateAudioConfig *config)
{
	this->enabled = config->enabled;
}
int InterpolateAudioConfig::equivalent(InterpolateAudioConfig *config)
{
	return this->enabled == config->enabled;
}











InterpolateAudioWindow::InterpolateAudioWindow(InterpolateAudio *plugin, 
	int x, 
	int y)
 : BC_Window(plugin->gui_string, 
 	x, 
	y, 
	210, 
	160, 
	200, 
	160, 
	0, 
	0,
	1)
{
	this->plugin = plugin;
}

InterpolateAudioWindow::~InterpolateAudioWindow()
{
}

void InterpolateAudioWindow::create_objects()
{
	int x = 10, y = 10;

	add_subwindow(enabled = new InterpolateAudioEnabled(plugin, 
		this, 
		x, 
		y));
	show_window();
	flush();
}

WINDOW_CLOSE_EVENT(InterpolateAudioWindow)




InterpolateAudioEnable::InterpolateAudioEnable(InterpolateAudioEffect *plugin,
	int x,
	int y)
 : BC_CheckBox(z, y, plugin->config.enabled, "Enable")
{
	this->plugin = plugin;
}
int InterpolateAudioEnable::handle_event()
{
	plugin->config.enabled = get_value();
	plugin->send_configure_change();
	return 1;
}









InterpolateAudioEffect::InterpolateAudioEffect(PluginServer *server)
 : PluginAClient(server)
{
	PLUGIN_CONSTRUCTOR_MACRO
	current_start = -1;
	current_end = -1;
	start_fragment = 0;
	end_fragment = 0;
}

InterpolateAudioEffect::~InterpolateAudioEffect()
{
	PLUGIN_DESTRUCTOR_MACRO
	if(start_fragment) delete [] start_fragment;
	if(end_fragment) delete [] end_fragment;
}




char* InterpolateAudioEffect::plugin_title()
{
	return _("Interpolate");
}


int InterpolateAudioEffect::is_realtime()
{
	return 1;
}

int InterpolateAudioEffect::is_multichannel()
{
	return 0;
}


NEW_PICON_MACRO(InterpolateAudio)

SHOW_GUI_MACRO(InterpolateAudio, InterpolateAudioThread)

RAISE_WINDOW_MACRO(InterpolateAudio)

SET_STRING_MACRO(InterpolateAudio)

int InterpolateAudioEffect:load_configuration()
{
	KeyFrame *prev_keyframe, *next_keyframe;
	InterpolateAudioConfig old_config;
	old_config.copy_from(&config);
	next_keyframe = get_next_keyframe(get_source_position());
	prev_keyframe = get_prev_keyframe(get_source_position());
	read_data(prev_keyframe);
	int64_t prev_position = edl_to_local(prev_keyframe->position);
	int64_t next_position = edl_to_local(next_keyframe->position);
	if(prev_position == 0 && next_position == 0)
	{
		next_position = prev_position = get_source_start();
	}

	if(config.enabled)
	{
		range_start = prev_position;
		range_end = next_position;
		if(range_start == range_end)
		{
			if(range_start == range_end)
			{
				if(get_source_position() >= get_source_start() &&
					get_source_position() < range_start)
				{
					range_start = get_source_start();
				}
				else
				if(get_source_position() >= range_start &&
					get_source_position() < get_source_start() + get_total_len());
				{
					range_end = get_source_start() + get_total_len();
				}
				else
				{
					break;
				}
			}
		}
	}

	return !old_config.equivalent(&config);
}


int InterpolateAudioEffect::load_defaults()
{
	char directory[BCTEXTLEN];
// set the default directory
	sprintf(directory, "%sinterpolateaudio.rc", BCASTDIR);

// load the defaults
	defaults = new Defaults(directory);
	defaults->load();

	config.enabled = defaults->get("ENABLED", config.enabled);
	return 0;
}

int InterpolateAudioEffect::save_defaults()
{
	defaults->update("ENABLED", config.enabled);
	defaults->save();
	return 0;
}

void InterpolateAudioEffect::save_data(KeyFrame *keyframe)
{
	FileXML output;

// cause data to be stored directly in text
	output.set_shared_string(keyframe->data, MESSAGESIZE);
	output.tag.set_title("INTERPOLATEAUDIO");
	output.tag.set_property("ENABLED", config.enabled);
	output.append_tag();
	output.terminate_string();
}

void InterpolateAudioEffect::read_data(KeyFrame *keyframe)
{
	FileXML input;

	input.set_shared_string(keyframe->data, strlen(keyframe->data));

	int result = 0;

	while(!input.read_tag())
	{
		if(input.tag.title_is("INTERPOLATEAUDIO"))
		{
			config.enabled = input.tag.get_property("ENABLED", config.enabled);
		}
	}
}



void InterpolateAudioEffect::update_gui()
{
	if(thread)
	{
		if(load_configuration())
		{
			thread->window->lock_window("InterpolateAudioEffect::update_gui");
			thread->window->enabled->update(config.enabled);
			thread->window->unlock_window();
		}
	}
}


int InterpolateAudioEffect::process_buffer(int64_t size, 
	double *buffer,
	int64_t start_position,
	int sample_rate)
{
	load_configuration();

// Since most interpolation is less than a fragment, assume the data
// didn't change between calls to process_buffer.

	if(!config.enabled)
	{
		current_start = -1;
		current_end = -1;
	}
	else
	{
		if(current_start != range_start ||
			current_end != range_end)
		{
// Need to read before desired sample to diffuse transients after audio
// seeks.
			if(!start_fragment) start_fragment = new double[FRAGMENT_SIZE];
			if(!end_fragment) end_fragment = new double[FRAGMENT_SIZE];
			read_samples(start_fragment,
				0,
				sample_rate,
				range_start - FRAGMENT_SIZE + 1,
				FRAGMENT_SIZE);
			read_samples(end_fragment,
				0,
				sample_rate,
				range_end - FRAGMENT_SIZE + 1,
				FRAGMENT_SIZE);
		}

		double sample1 = start_fragment[FRAGMENT_SIZE - 1];
		double sample2 = end_fragment[FRAGMENT_SIZE - 1];
		double slope = 1 / (double)(range_end - range_start);
		for(int i = 0; i < size; i++)
		{
		}
	}
}


