#ifndef DECORE_BITSTREAM_H_
#define DECORE_BITSTREAM_H_

#include "dec_portab.h"
#include "decoder.h"


// vop coding types 
// intra, prediction, backward, sprite, not_coded
#define I_VOP	0
#define P_VOP	1
#define B_VOP	2
#define S_VOP	3
#define N_VOP	4

typedef struct
{
	uint32_t bufa;
	uint32_t bufb;
	uint32_t pos;
	uint32_t * head;
} BITSTREAM;



// header stuff
int bs_vol(BITSTREAM * bs, DECODER * dec);
int bs_vop(BITSTREAM * bs, DECODER * dec, uint32_t * rounding, uint32_t * quant, uint32_t * fcode);


void bs_init(BITSTREAM * const bs, void * const bitstream);




static uint32_t __inline bs_show(BITSTREAM * const bs, const uint32_t bits)
{
	int nbit = (bits + bs->pos) - 32;
	if (nbit > 0) 
	{
		return ((bs->bufa & (0xffffffff >> bs->pos)) << nbit) |
				(bs->bufb >> (32 - nbit));
	}
	else 
	{
		return (bs->bufa & (0xffffffff >> bs->pos)) >> (32 - bs->pos - bits);
	}
}



static __inline void bs_skip(BITSTREAM * const bs, const uint32_t bits)
{
	bs->pos += bits;

	if (bs->pos >= 32) 
	{
		uint32_t tmp;

		bs->bufa = bs->bufb;
		tmp = *(uint32_t *)bs->head;
#ifndef BIG_ENDIAN
		BSWAP(tmp);
#endif
		bs->bufb = tmp;
		bs->head ++;
		bs->pos -= 32;
	}
}



static __inline void bs_bytealign(BITSTREAM * const bs)
{
	uint32_t remainder = bs->pos % 8;
	if (remainder)
	{
		bs_skip(bs, 8 - remainder);
	}
}



static uint32_t __inline bs_get(BITSTREAM * const bs, const uint32_t n)
{
	uint32_t ret = bs_show(bs, n);
	bs_skip(bs, n);
	return ret;
}


static uint32_t __inline bs_get1(BITSTREAM * const bs)
{
	return bs_get(bs, 1);
}


#endif /* _BITSTREAM_H_ */