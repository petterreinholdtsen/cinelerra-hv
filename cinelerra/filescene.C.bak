/*
 * CINELERRA
 * Copyright (C) 2011 Adam Williams <broadcast at earthling dot net>
 * 
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 * 
 */



#include "affine.h"
#include "asset.h"
#include "bcsignals.h"
#include "file.h"
#include "filescene.h"
#include "filesystem.h"
#include "libmjpeg.h"
#include "overlayframe.h"


#include <ctype.h>
#include <errno.h>
#include <stdlib.h>
#include <string.h>
#include <sys/stat.h>


extern void get_exe_path(char *result);

// Paths relative to the exe path
#define FESTIVAL_PATH "/festival"
#define FESTIVAL_LIB_PATH "/lib/"
#define ASSET_PATH "/models/"
#define FREAD_SIZE 0x10000


#define STRIP_LINE(string) \
/* Strip linefeeds */ \
	while(len > 0 && (string[len - 1] == '\n' || \
		string[len - 1] == ' ')) \
	{ \
		string[len - 1] = 0; \
		len--; \
	} \
 \
/* Strip comments */ \
	for(i = 0; i < len; i++) \
	{ \
		if(string[i] == '#') \
		{ \
			string[i] = 0; \
			i = len; \
		} \
	}




#define STRING_PARAMETER(title, need_char, dst) \
if(!strncmp(command, title, strlen(title))) \
{ \
/* advance to argument */ \
	i += strlen(title); \
	while(string[i] != 0 && string[i] == ' ') \
		i++; \
 \
	if(current_char || !need_char) \
	{ \
/* printf("STRING_PARAMETER %s %s %p\n", title, string + i, dst); */ \
		strcpy(dst, string + i); \
	} \
	else \
	{ \
		printf("FileScene::read_script %d Line %d: %s but no current character\n",  \
			__LINE__, \
			title, \
			current_line); \
	} \
 \
	i = len; \
}

static int read_parameter(char *string,
	int *i,
	const char *title, 
	char *dst_string, 
	float *dst_float0, 
	float *dst_float1, 
	float *dst_float2)
{
	char *command = string + *i;
	char *arg_text[3];

	if(!strncmp(command, title, strlen(title)))
	{
		*i += strlen(title);

		for(int j = 0; j < 4; j++)
		{
/* skip to start of argument */
			while(string[*i] != 0 && string[*i] == ' ')
				(*i)++;

			if(string[*i] != 0)
			{
				arg_text[j] = string + *i;
				while(string[*i] != 0 && string[*i] != ' ')
					(*i)++;
			}
			else
			{
				arg_text[j] = 0;
			}
 		}

// printf("read_parameter %d %s %s %s %s\n", 
// __LINE__, 
// title, 
// arg_text[0], 
// arg_text[1], 
// arg_text[2]);

		if(arg_text[0])
		{
			if(dst_string)
			{
				char *ptr1 = dst_string;
				char *ptr2 = arg_text[0];
				while(*ptr2 != 0 && *ptr2 != ' ')
					*ptr1++ = *ptr2++;
				*ptr1 = 0;
			}
			else
			if(dst_float0)
			{
				*dst_float0 = atof(arg_text[0]);
			}
		}

		if(arg_text[1])
		{
			if(dst_float1)
			{
				*dst_float1 = atof(arg_text[1]);
			}
		}

		if(arg_text[2])
		{
			if(dst_float2)
			{
				*dst_float2 = atof(arg_text[2]);
			}
		}

		return 1;
	}

	return 0;
}













FileScene::FileScene(Asset *asset, File *file)
 : FileBase(asset, file)
{
	reset_parameters();
	get_exe_path(exe_path);
}


FileScene::~FileScene()
{
	close_file();
}



int FileScene::open_file(int rd, int wr)
{
// Set asset format
	asset->format = FILE_SCENE;
	asset->video_data = 1;
// Should be set in the scene file
	asset->layers = 1;
	asset->width = 1280;
	asset->height = 720;
// Dictated by character animations
	asset->frame_rate = 10;
// Some arbitrary default length.
// Hard to calculate without rendering it.
	asset->video_length = -1;



	asset->audio_data = 1;
// The speech synthesizer outputs different samplerates depending on the speaker.
// The heroine voices are all 16khz
	asset->sample_rate = 16000;
// Mono voice placement for now
// Maybe a different track for each voice in the future or 3D positioning
	asset->channels = 1;
	asset->audio_length = -1;


	return 0;
}

int FileScene::close_file()
{
	delete script;
	delete [] audio_temp;
	delete overlayer;
	delete camera_temp;
	delete affine;
	FileBase::close_file();
	return 0;
}


int FileScene::check_sig(Asset *asset, char *test)
{
	if(!strncmp(test, "TEXT2MOVIE", 10)) return 1;

	return 0;
}



int FileScene::set_video_position(int64_t x)
{
	return 0;
}


int FileScene::set_audio_position(int64_t x)
{
	return 0;
}


int FileScene::read_frame(VFrame *frame)
{
// Everything is timed based on speech, so render the audio for this frame.
	const int debug = 0;
	
	
	frame->clear_frame();
	int64_t audio_position1 = (int64_t)(file->current_frame * 
		asset->sample_rate /
		asset->frame_rate);
	int64_t audio_position2 = (int64_t)(audio_position1 + 
		asset->sample_rate /
		asset->frame_rate);

	if(debug) printf("FileScene::read_frame %d frame=%lld frame_rate=%f sample_rate=%d audio_position1=%lld audio_position2=%lld\n",
		__LINE__,
		file->current_frame,
		asset->frame_rate,
		asset->sample_rate,
		audio_position1,
		audio_position2);

	render_chunks(audio_position1, audio_position2 - audio_position1);
	if(!script) return 1;
	if(debug) printf("FileScene::read_frame %d\n", __LINE__);

//	script->dump();


// Determine lip position from amplitude
	double accum = 0;
	for(int i = 0; i < audio_position2 - audio_position1; i++)
	{
		double sample_float = fabs((double)audio_temp[i] / 32768);
		if(sample_float > accum) accum = sample_float;
	}
	if(debug) printf("FileScene::read_frame %d accum=%f\n", __LINE__, accum);

// Reset cameras
	for(int i = 0; i < script->total_characters(); i++)
	{
		SceneChar *character = script->get_character(i);
		character->current_camera = SceneChar::CAMERA_WIDE;
	}

// Now determine which character is speaking from the sample times.
	int64_t current_sample = 0;
	SceneChar *speeking_character = 0;
	double max = 0;
// Sample relative to start of chunk
	int64_t chunk_sample = 0;
	for(int i = 0; i < script->total_chunks(); i++)
	{
		SceneChunk *chunk = script->get_chunk(i);
		int samples = chunk->audio_size / 2;

		if(audio_position1 >= current_sample && 
			audio_position1 < current_sample + samples)
		{
			speeking_character = chunk->character;
			max = chunk->max;
			chunk_sample = audio_position1 - current_sample;
			break;
		}

		chunk->character->increment_camera();
		current_sample += samples;
	}



// Render the scene.
// Store component placement in a scene graph.
	SceneGraph scene;


// Scale for the entire scene
	float scale = 1;
	if(speeking_character)
	{
		if(debug) printf("FileScene::read_frame %d frame=%lld accum=%f character=%s\n", 
			__LINE__, 
			file->current_frame,
			accum,
			speeking_character->name);


// If closeup, increase scene scale
		if(speeking_character->current_camera == SceneChar::CAMERA_CU)
		{
			scale = 2;
		}
	}

// Render background
	if(script->background[0])
	{
		script->render_background(&scene);
	}

// Render characters
	for(int i = 0; i < script->total_characters(); i++)
	{
		SceneChar *character = script->get_character(i);
		int flip = 0;
		int rotate_head = 0;

		character->read_model();

// Logical character placement
		switch(script->total_characters())
		{
			case 1:
				character->x = (int)(asset->width / 2 - character->w / 2);
				character->y = (int)(asset->height - character->h);
				break;

			case 2:
				if(i == 0)
				{
					character->x = 0;
					character->y = (int)(asset->height - character->h);
				}
				else
				{
					character->x = (int)(asset->width - character->w);
					character->y = (int)(asset->height - character->h);
					flip = 1;
				}
				break;

			case 3:
				if(i == 0)
				{
					character->x = 0;
					character->y = (int)(asset->height - character->h);
				}
				else
				if(i == 1)
				{
					character->x = (int)(asset->width / 2 - character->w / 2);
					character->y = (int)(asset->height - character->h);
				}
				else
				{
					character->x = (int)(asset->width - character->w);
					character->y = (int)(asset->height - character->h);
					flip = 1;
				}
				break;
		}

// Clamp the head
		if(character->y < 0) character->y = 0;

// Speeker head movement
		if(speeking_character == character)
		{
			rotate_head = (chunk_sample / asset->sample_rate / 2) % 2;
		}

// Temporaries for rotation & flipping
		VFrame *temp_head = 0;
		VFrame *temp_body = 0;
		VFrame *temp_mouth = 0;
		VFrame *body_image = character->body;
		VFrame *head_image = character->head;

// Compute the mouth image
		VFrame *mouth_image = 0;
		int fraction = 0;
		if(character == speeking_character && max > 0)
		{
			fraction = (int)(accum * character->mouths.size() / max);
			if(fraction >= character->mouths.size())
				fraction = character->mouths.size() - 1;
		}

//printf("FileScene::read_frame %d i=%d %f %f %d\n", __LINE__, i, accum, max, fraction);

		mouth_image = character->mouths.get(fraction);

// Compute coordinates of body parts
		int mouth_x = character->x + character->mouth_x.get(fraction);
		int mouth_y = character->y + character->mouth_y.get(fraction);
		int head_x = character->x + character->head_x;
		int head_y = character->y + character->head_y;
		int body_x = character->x + character->body_x;
		int body_y = character->y + character->body_y;



// Rotate & flip head
		if(rotate_head || flip)
		{
			temp_head = new VFrame(head_image->get_w(),
				head_image->get_h(),
				head_image->get_color_model());
			temp_mouth = new VFrame(mouth_image->get_w(),
				mouth_image->get_h(),
				mouth_image->get_color_model());

			if(rotate_head)
			{
				if(!affine) affine = new AffineEngine(file->cpus, file->cpus);

//				affine->set_in_pivot(head_image->get_w() / 2, 
//					head_image->get_h());
				affine->rotate(temp_head,
					head_image,
					-5);

//				affine->set_in_pivot(head_image->get_w() / 2 - mouth_x, 
//					head_image->get_h() - mouth_y);
				affine->rotate(temp_mouth,
					mouth_image,
					-5);
			}
			else
			{
				temp_head->copy_from(head_image);
				temp_mouth->copy_from(mouth_image);
			}
			
			if(flip)
			{
				temp_head->flip_horiz();
				temp_mouth->flip_horiz();

				head_x = character->x +
					character->w -
					character->head_x -
					head_image->get_w();
				mouth_x = character->x + 
					character->w - 
					character->mouth_x.get(fraction) - 
					mouth_image->get_w();

			}

			head_image = temp_head;
			mouth_image = temp_mouth;
		}
		


// Flip body
		if(flip)
		{
			temp_body = new VFrame(body_image->get_w(),
				body_image->get_h(),
				body_image->get_color_model());

			temp_body->copy_from(body_image);

			temp_body->flip_horiz();

	
			body_x = character->x + 
				character->w - 
				character->body_x - 
				body_image->get_w();

			body_image = temp_body;
		}

// Draw it
		if(!overlayer) overlayer = new OverlayFrame(file->cpus);

		overlayer->overlay(dst_frame, 
			head_image, 
			0, 
			0, 
			head_image->get_w(), 
			head_image->get_h(), 
			head_x, 
			head_y, 
			head_x + head_image->get_w(), 
			head_y + head_image->get_h(), 
			1,
			TRANSFER_NORMAL,
			NEAREST_NEIGHBOR);

		overlayer->overlay(dst_frame, 
			body_image, 
			0, 
			0, 
			body_image->get_w(), 
			body_image->get_h(), 
			body_x, 
			body_y, 
			body_x + body_image->get_w(), 
			body_y + body_image->get_h(), 
			1,
			TRANSFER_NORMAL,
			NEAREST_NEIGHBOR);

		overlayer->overlay(dst_frame, 
			mouth_image, 
			0, 
			0, 
			mouth_image->get_w(), 
			mouth_image->get_h(), 
			mouth_x, 
			mouth_y, 
			mouth_x + mouth_image->get_w(), 
			mouth_y + mouth_image->get_h(), 
			1,
			TRANSFER_NORMAL,
			NEAREST_NEIGHBOR);

// printf("FileScene::read_frame %d i=%d x=%d y=%d mouth_x=%d mouth_y=%d\n",
// 	__LINE__,
// 	i,
// 	x,
// 	y,
// 	mouth_x,
// 	mouth_y);

		delete temp_body;
		delete temp_mouth;
		delete temp_head;
	}

	if(speeking_character &&
		speeking_character->current_camera == SceneChar::CAMERA_CU)
	{
// Zoom in on speaker
		int in_x = speeking_character->x + speeking_character->w / 2 - asset->width / 4;
		int in_y = speeking_character->y;
		int in_w = asset->width / 2;
		int in_h = asset->height / 2;
		if(in_x < 0)
		{
			in_x = 0;
		}
		if(in_x + in_w > asset->width)
		{
			in_x = asset->width - in_w;
		}



		overlayer->overlay(frame, 
			dst_frame, 
			in_x, 
			in_y, 
			in_x + in_w, 
			in_y + in_h, 
			0, 
			0, 
			dst_frame->get_w(), 
			dst_frame->get_h(), 
			1,
			TRANSFER_REPLACE,
			NEAREST_NEIGHBOR);
		
	}

	return 0;
}


int FileScene::read_samples(double *buffer, int64_t len)
{
// Speech rendering
// Everything is timed based on speech, so we have to do this for video, too.
	render_chunks(file->current_sample, len);

//	script->dump();


// Convert temp to output
	for(int i = 0; i < len; i++)
	{
		buffer[i] = (double)audio_temp[i] / 32768;
	}

	return 0;
}


int64_t FileScene::get_memory_usage()
{
//PRINT_TRACE
	int total = 0x100000;
	if(script)
	{
		total += script->get_memory_usage();
		
	}
//PRINT_TRACE
	return total;
}



int FileScene::get_best_colormodel(Asset *asset, int driver)
{
	return 0;
}


int FileScene::colormodel_supported(int colormodel)
{
	return BC_RGBA8888;
}


int FileScene::can_copy_from(Asset *asset, int64_t position)
{
	return 0;
}


int FileScene::reset_parameters_derived()
{
	script = 0;
	audio_temp = 0;
	temp_allocated = 0;
	overlayer = 0;
	camera_temp = 0;
	affine = 0;
	return 0;
}



void FileScene::render_chunks(int64_t start_position, int64_t len)
{
	int64_t end_position = start_position + len;
	const int debug = 0;


	if(debug) printf("FileScene::render_chunks %d start_position=%lld len=%lld\n",
		__LINE__,
		start_position,
		len);

// Update script
	read_script();

	if(!script) return;

	if(debug) PRINT_TRACE

// Reallocate temp buffer
	if(len > temp_allocated)
	{
		delete [] audio_temp;
		audio_temp = new int16_t[len];
		temp_allocated = len;
	}
	bzero(audio_temp, sizeof(int16_t) * len);

	if(debug) PRINT_TRACE
// Find start_position in script output
	int64_t current_sample = 0;
	for(int i = 0; i < script->total_chunks(); i++)
	{
		SceneChunk *chunk = script->get_chunk(i);
		chunk->used = 0;
		if(debug) printf("FileScene::render_chunks %d\n", __LINE__);

// If extent of audio output hasn't been calculated, render it
		if(!chunk->audio_size)
		{
			if(debug) printf("FileScene::render_chunks %d i=%d\n", __LINE__, i);
			chunk->render();
		}

// Dialog chunk is inside output buffer
		if(current_sample + chunk->audio_size > start_position &&
			current_sample < end_position)
		{
			if(debug) printf("FileScene::render_chunks %d\n", __LINE__);
// If no audio output exists, render it
			if(!chunk->audio)
			{
				chunk->render();
			}

			if(debug) printf("FileScene::render_chunks %d: Using \"%s\" samples=%d\n",
				__LINE__,
				chunk->text,
				chunk->audio_size / 2);
			if(debug) printf("FileScene::render_chunks %d: start_position=%lld current_sample=%lld\n",
				__LINE__,
				start_position,
				current_sample);

// Memcpy it.
// TODO: allow characters to talk simultaneously
			int64_t src_offset = start_position - current_sample;
			int64_t dst_offset = 0;
			int64_t src_len = chunk->audio_size / 2 - src_offset;

			if(debug) printf("FileScene::render_chunks %d: src_offset=%lld dst_offset=%lld src_len=%lld\n",
				__LINE__,
				src_offset,
				dst_offset,
				src_len);

			if(src_offset < 0)
			{
				dst_offset -= src_offset;
				src_len += src_offset;
				src_offset = 0;
			}

			if(dst_offset + src_len > len)
			{
				src_len = len - dst_offset;
			}

			if(debug) printf("FileScene::render_chunks %d: src_offset=%lld dst_offset=%lld src_len=%lld\n",
				__LINE__,
				src_offset,
				dst_offset,
				src_len);
			for(int j = 0; j < src_len; j++)
			{
				audio_temp[dst_offset + j] = 
					chunk->audio[(src_offset + j) * 2] | 
					(chunk->audio[(src_offset + j) * 2 + 1] << 8);
			}

			if(debug) printf("FileScene::render_chunks %d\n", __LINE__);
			chunk->used = 1;
		}

		current_sample += chunk->audio_size / 2;
	}

// Erase unused dialog chunks
	if(debug) printf("FileScene::render_chunks %d\n", __LINE__);
	for(int i = 0; i < script->total_chunks(); i++)
	{
		SceneChunk *chunk = script->get_chunk(i);
		if(!chunk->used)
		{
			delete [] chunk->audio;
			chunk->audio = 0;
			chunk->audio_allocated = 0;
		}
	}
	if(debug) printf("FileScene::render_chunks %d\n", __LINE__);
	
	
}



int FileScene::read_script()
{
	const int debug = 0;
	struct stat ostat;
	if(stat(asset->path, &ostat))
	{
		printf("FileScene::read_script %d: %s\n", __LINE__, strerror(errno));
		return 1;
	}

// Test timestamp
	if(script)
	{
		if(ostat.st_mtime == script->timestamp)
		{
			if(debug) printf("FileScene::read_script %d: script unchanged\n", __LINE__);
			return 0;
		}
	}


// Read new script
	delete script;
	script = 0;
	if(!script) script = new SceneTokens(this, file->cpus);
	script->timestamp = ostat.st_mtime;

	script->read_script(asset->path);

	return 1;
}







SceneObject::SceneObject(SceneTokens *script, char *path, float x, float y)
{
	image = 0;
	this->script = script;
	this->x = x;
	this->y = y;
	image = script->load_image(path);
}

SceneObject::~SceneObject()
{
	delete image;
}








SceneChar::SceneChar(SceneTokens *script)
{
	this->script = script;
	name[0] = 0;
	voice[0] = 0;
	body = 0;
	head = 0;
	sprintf(model, "heroine01");
	current_camera = CAMERA_WIDE;
	faces_left = 0;
	sx = sy = sz = 1;
}

SceneChar::~SceneChar()
{
	mouths.remove_all_objects();
	eyes.remove_all_objects();
	delete body;
	delete head;
}


void SceneChar::increment_camera()
{
	current_camera++;
	if(current_camera >= CAMERA_TOTAL) 
		current_camera = 0;
}


void SceneChar::read_model()
{
// Read descriptor file
	const int debug = 0;
	int current_line = 0;
	float x, y;
	int i;

// Already read it
	if(body) return;

	script->convert_path(path, model);
	FILE *fd = fopen(path, "r");
	

// Read assets
	if(fd)
	{
// Read 1 line
		char string[BCTEXTLEN];
		char string2[BCTEXTLEN];

		while(!feof(fd))
		{
			char *result = fgets(string, BCTEXTLEN, fd);
			
			if(result)
			{
				int len = strlen(string);

				STRIP_LINE(string);

				if(debug) printf("SceneChar::read_model %d: %s\n", 
					__LINE__, 
					string);
			
				for(i = 0; i < len; i++)
				{
					if(isalnum(string[i]))
					{
						mouth_path[0] = 0;
						body_path[0] = 0;
						
						if(read_parameter(string,
							&i,
							"width:", 
							0, 
							&w, 
							0, 
							0))
						{
						}
						else
						if(read_parameter(string,
							&i,
							"height:", 
							0, 
							&h, 
							0, 
							0))
						{
						}
						else
						if(read_parameter(string,
							&i,
							"body:", 
							string2, 
							0, 
							&x, 
							&y))
						{
// Load image
							body = new SceneObject(script, string2, x, y);
						}
						else
						if(read_parameter(string,
							&i,
							"head:", 
							string2, 
							0, 
							&x, 
							&y))
						{
// Load image
							head = new SceneObject(script, string2, x, y);
						}
						else
						if(read_parameter(string,
							&i,
							"mouth:", 
							string2, 
							0, 
							&x, 
							&y))
						{
// Load image
							mouths.append(new SceneObject(script, string2, x, y));
						}
						else
						if(read_parameter(string,
							&i,
							"eyes:", 
							string2, 
							0, 
							&x, 
							&y))
						{
// Load image
							eyes.append(new SceneObject(script, string2, x, y));
						}
						else
						if(read_parameter(string,
							&i,
							"faces_left", 
							0, 
							0, 
							0, 
							0))
						{
							faces_left = 1;
						}
						else
						if(read_parameter(string,
							&i,
							"scale:", 
							0, 
							&sz, 
							0, 
							0))
						{
							sx = sy = sz;
						}
						
						i = len;
					}
				}
			}
			
			current_line++;
		}
		
		fclose(fd);
		if(debug) dump();
		return;
	}
	
	printf("SceneChar::read_model %d: %s %s", __LINE__, path, strerror(errno));
}

int SceneChar::get_memory_usage()
{
	int total = 0;
	if(body) total += body->get_memory_usage();
	if(head) total += head->get_memory_usage();
	for(int i = 0; i < mouths.size(); i++)
		total += mouths.get(i)->get_memory_usage();
	return total;
}

void SceneChar::dump()
{
	printf("SceneChar::dump %d: name=%s voice=%s model=%s body=%p mouths=%d\n", 
		__LINE__, 
		name, 
		voice, 
		model,
		body,
		mouths.size());
	printf("SceneChar::dump %d: w=%f h=%f\n", __LINE__, w, h);


	for(int i = 0; i < mouths.size(); i++)
	{
		printf("    mouth=%p x=%f y=%f\n", mouths.get(i), mouth_x.get(i), mouth_y.get(i));
	}
}









// Dialog from a single character
SceneChunk::SceneChunk(SceneTokens *script)
{
	text = 0;
	character = 0;
	audio = 0;
	audio_size = 0;
	audio_allocated = 0;
	used = 0;
	max = 0;
	this->script = script;
}

SceneChunk::~SceneChunk()
{
	delete [] text;
	delete [] audio;
}

void SceneChunk::dump()
{
	printf("SceneChunk::dump %d: character=%s text=%s\n", 
		__LINE__, 
		character->name,
		text);
	printf("SceneChunk::dump %d: audio=%p audio_size=%d\n",
		__LINE__,
		audio,
		audio_size);
}

int SceneChunk::get_memory_usage()
{
	return audio_allocated;
}


void SceneChunk::append_text(char *new_text)
{
	char string[BCTEXTLEN];

// Replace "
// Convert ' to \'
	char *ptr = string;
	for(int i = 0; i < strlen(new_text); i++)
	{
		if(new_text[i] == '"')
			*ptr++ = ' ';
		else
		if(new_text[i] == '\'')
		{
			*ptr++ = '\\';
			*ptr++ = '\'';
			*ptr++ = '\'';
		}
		else
			*ptr++ = new_text[i];
	}
	*ptr++ = 0;
	
	int len2 = strlen(string);
	if(text)
	{
		int len1 = strlen(text);
		int len3 = 1;
		int need_space = 0;

//		if(len1 > 0 && isalnum(text[len1 - 1]))
		if(len1 > 0 && text[len1 - 1] != ' ')
		{
			need_space = 1;
			len3++;
		}

		text = (char*)realloc(text, len1 + len2 + len3);

// Append space
		if(need_space)
		{
			text[len1] = ' ';
			text[len1 + 1] = 0;
		}
	}
	else
	{
		text = new char[len2 + 1];
		text[0] = 0;
	}

	strcat(text, string);
}

void SceneChunk::render()
{
	const int debug = 0;
	int len = strlen(text);
	char *command_line = new char[BCTEXTLEN + len];

	if(!character)
	{
		printf("SceneChunk::render %d: no character defined.\n", __LINE__);
	}

	sprintf(command_line, 
		"%s%s --libdir %s%s -b "
		"'(voice_%s)' "
		"'(set! utt1 (Utterance Text \"%s\"))' "
		"'(utt.synth utt1)' "
		"'(utt.save.wave utt1 \"-\")'",
		script->file->exe_path,
		FESTIVAL_PATH, 
		script->file->exe_path,
		FESTIVAL_LIB_PATH,
		character->voice,
		text);



// 	sprintf(command_line, 
// 		"echo \"%s\" | %s/%s -eval \'(voice_%s)\'", 
// 		text,
// 		script->file->exe_path,
// 		FESTIVAL_PATH, 
// 		character->voice);

	if(debug) printf("SceneChunk::render %d: %s\n", 
		__LINE__,
		command_line);

	audio_size = 0;

// popen only does half duplex	
	FILE *fd = popen(command_line, "r");
// Capture output
	if(fd)
	{
		if(debug) printf("SceneChunk::render %d\n", 
			__LINE__);
		while(!feof(fd))
		{
			if(debug) printf("SceneChunk::render %d\n", 
				__LINE__);
			if(audio_size + FREAD_SIZE > audio_allocated)
			{
				audio_allocated += FREAD_SIZE;
				audio = (unsigned char*)realloc(audio, audio_allocated);
			}

			if(debug) printf("SceneChunk::render %d audio=%p audio_size=%d\n", 
				__LINE__,
				audio,
				audio_size);

			int bytes_read = fread(audio + audio_size, 1, FREAD_SIZE, fd);
			if(debug) printf("SceneChunk::render %d\n", 
				__LINE__);
			audio_size += bytes_read;
			if(bytes_read < FREAD_SIZE)
			{
				break;
			}
		}

		pclose(fd);
		if(debug) printf("SceneChunk::render %d audio=%p audio_size=%d audio_allocated=%d\n", 
			__LINE__,
			audio,
			audio_size,
			audio_allocated);
	
// Strip WAV header
		if(audio_size > 44)
		{
			memcpy(audio, audio + 44, audio_size - 44);
			audio_size -= 44;
			if(debug) printf("SceneChunk::render %d: audio_size=%d\n",
				__LINE__,
				audio_size);

// Calculate loudest part
			max = 0;
			for(int i = 0; i < audio_size; i += 2)
			{
				int16_t sample = audio[i] |
					(audio[i + 1] << 8);
				double sample_float = fabs((double)sample / 32768);
				if(sample_float > max) max = sample_float;
			}
		}
	}
	else
	{
		printf("SceneChunk::render %d: Couldn't run %s: %s\n",
			__LINE__,
			command_line,
			strerror(errno));
	}

	if(debug) printf("SceneChunk::render %d max=%f\n", 
		__LINE__,
		max);
	delete [] command_line;
	if(debug) printf("SceneChunk::render %d\n", 
		__LINE__);
}













SceneTokens::SceneTokens(FileScene *file, int cpus)
{
	background[0] = 0;
	background_image = 0;
	timestamp = 0;
	this->cpus = cpus;
	this->file = file;
	overlayer = 0;
}

SceneTokens::~SceneTokens()
{
	chunks.remove_all_objects();
	characters.remove_all_objects();
	delete background_image;
	delete overlayer;
}

SceneChar* SceneTokens::get_character(char *name)
{
	const int debug = 0;
	if(debug) printf("SceneTokens::get_character %d %d\n",
		__LINE__,
		characters.size());

	for(int i = 0; i < characters.size(); i++)
	{
		if(!strcmp(characters.get(i)->name, name)) return characters.get(i);
	}
	if(debug) printf("SceneTokens::get_character %d %d\n",
		__LINE__,
		characters.size());
	
	SceneChar *result = new SceneChar(this);
	if(debug) printf("SceneTokens::get_character %d %d this=%p\n",
		__LINE__,
		characters.size(),
		&characters);

	characters.append(result);
	if(debug) printf("SceneTokens::get_character %d %d\n",
		__LINE__,
		characters.size());

	strcpy(result->name, name);
	if(debug) printf("SceneTokens::get_character %d %d\n",
		__LINE__,
		characters.size());

	result->read_model();
	if(debug) printf("SceneTokens::get_character %d %d\n",
		__LINE__,
		characters.size());

	return result;
}

SceneChar* SceneTokens::get_character(int number)
{
	return characters.get(number);
}

SceneChunk* SceneTokens::new_chunk()
{
	SceneChunk *result = new SceneChunk(this);
	chunks.append(result);
	return result;
}

int SceneTokens::total_chunks()
{
	return chunks.size();
}

int SceneTokens::total_characters()
{
	return characters.size();
}

SceneChunk* SceneTokens::get_chunk(int number)
{
	return chunks.get(number);
}

int SceneTokens::read_script(char *path)
{
	const int debug = 0;

	strcpy(this->path, path);

	FILE *fd = fopen(path, "r");
	if(fd)
	{
// Read 1 line
		char string[BCTEXTLEN];
// Current character name
		char char_name[BCTEXTLEN];
		SceneChar *current_char = 0;
		char_name[0] = 0;
		SceneChunk *current_chunk = 0;
		int current_line = 0;
		int i;

		while(!feof(fd))
		{
			char *result = fgets(string, BCTEXTLEN, fd);
			current_line++;

			if(result)
			{
				int len = strlen(string);
				STRIP_LINE(string)

				if(debug) printf("SceneTokens::read_script %d: %s\n", 
					__LINE__, 
					string);

// Skip the file ID & empty lines
				if(string[0] == 0 ||
					!strncmp(string, "TEXT2MOVIE", 10))
					continue;

				int got_it = 0;
				for(i = 0; i < len; i++)
				{
					if(isalnum(string[i]))
					{
						got_it = 1;
						i = len;
					}
				}

				if(!got_it) continue;

// A line all in caps is a character name
				got_it = 1;
				for(i = 0; i < len; i++)
				{
					if(islower(string[i]))
					{
						got_it = 0;
						i = len;
					}
				}

				if(got_it)
				{
					strcpy(char_name, string);

					if(debug) printf("SceneTokens::read_script %d: char_name=%s\n", 
						__LINE__, 
						char_name);

					current_char = get_character(char_name);

					if(debug) printf("SceneTokens::read_script %d current_char=%p\n", 
						__LINE__, 
						current_char);

// Reset the current chunk pointer
					current_chunk = 0;
					i = len;
				}
				else
					i = 0;

// Certain words are commands
				for(; i < len; i++)
				{
					if(isalnum(string[i]))
					{
						char *command = string + i;

						STRING_PARAMETER("voice:", 1, current_char->voice)
						else
						STRING_PARAMETER("model:", 1, current_char->model)
						else
						STRING_PARAMETER("background:", 0, background)
						else
// Default is dialogue
						{
							if(!current_char)
							{
								printf("SceneTokens::read_script %d Line %d: dialogue text but no current character\n", 
									__LINE__,
									current_line);
							}
							else
							{
								if(!current_chunk)
								{
									current_chunk = new_chunk();
									current_chunk->character = current_char;
								}

// Append dialogue to current chunk
								current_chunk->append_text(string + i);
							}
							
							i = len;
						}
					}
				}
			}
		}
		
		
		
		fclose(fd);
		
		if(debug) dump();
		return 0;
	}

	printf("SceneTokens::read_script %d: %s %s", __LINE__, path, strerror(errno));
	return 1;
}

void SceneTokens::convert_path(char *dst, char *src)
{
	char string[BCTEXTLEN];

// Absolute path in src
	if(src[0] == '/')
	{
		strcpy(dst, src);
	}
	else
// Relative path
	{
// Try directory of script
		FileSystem fs;
		fs.extract_dir(dst, path);
		strcat(dst, src);
		
		struct stat ostat;
		if(stat(dst, &ostat))
		{
// Try cinelerra directory
			get_exe_path(dst);
			strcat(dst, ASSET_PATH);
			strcat(dst, src);
//printf("SceneTokens::convert_path %d %s\n", __LINE__, dst);
		}
	}
}

VFrame* SceneTokens::load_image(char *path)
{
	VFrame *result = 0;
	char complete_path[BCTEXTLEN];
	convert_path(complete_path, path);

	int64_t size = FileSystem::get_size(complete_path);
	if(!size)
	{
		printf("SceneTokens::load_image %d: Couldn't open %s\n",
			__LINE__,
			complete_path);
		return 0;
	}

	unsigned char *data = new unsigned char[size + 4];
	FILE *fd = fopen(complete_path, "r");
	fread(data + 4, 1, size, fd);
	data[0] = (size >> 24) & 0xff;
	data[1] = (size >> 16) & 0xff;
	data[2] = (size >> 8) & 0xff;
	data[3] = size & 0xff;
	result = new VFrame(data);
	delete [] data;
	return result;
}

void SceneTokens::render_background(SceneGraph *scene)
{
// Decompress background image
	if(!background_image)
	{
		background_image = load_image(background);
	}
	
	if(background_image)
	{
		SceneNode *node = new SceneNode;
		scene->append_node(node);



		if(!overlayer) overlayer = new OverlayFrame(cpus);

		overlayer->overlay(frame, 
			background_image, 
			0, 
			0, 
			background_image->get_w(), 
			background_image->get_h(), 
			0, 
			0, 
			background_image->get_w(), 
			background_image->get_h(), 
			1,
			TRANSFER_NORMAL,
			NEAREST_NEIGHBOR);
	}
}

int SceneTokens::get_memory_usage()
{
	int total = 0;
	if(background_image) total += background_image->get_memory_usage();
	for(int i = 0; i < total_chunks(); i++)
	{
		total += get_chunk(i)->get_memory_usage();
	}
	for(int i = 0; i < total_characters(); i++)
	{
		total += get_character(i)->get_memory_usage();
	}
	return total;
}


void SceneTokens::dump()
{
	printf("SceneTokens::dump %d background=%s\n", __LINE__, background);
	for(int i = 0; i < characters.size(); i++)
	{
		characters.get(i)->dump();
	}

	
	for(int i = 0; i < chunks.size(); i++)
	{
		chunks.get(i)->dump();
	}
}




