***************
*** 25,35 ****
  
  
  
  
  File::File()
  {
  	cpus = 1;
  	asset = new Asset;
  	reset_parameters();
  }
  
--- 26,288 ----
  
  
  
+  FrameCache::FrameCache(int64_t cache_size) 
+  {
+  	cache_enabled = 1;
+  	this->cache_size = cache_size;
+ 	memory_used = 0;
+  	timer.update();
+  }
+  
+  FrameCache::~FrameCache() 
+  {
+ 	reset();
+  }
+  
+  void FrameCache::reset() 
+  {	
+  	change_lock.lock();
+  	FrameCacheTree::iterator iterator = cache_tree.begin();
+  	while (iterator != cache_tree.end()) {
+  		delete iterator->second;
+  		iterator++;
+ 	}
+  	cache_tree.clear();
+  	cache_tree_bytime.clear();
+ 	memory_used = 0;
+  	change_lock.unlock();
+  }
+ 
+  void FrameCache::set_size(int64_t cache_size) 
+  {
+ 	this->cache_size = cache_size;
+  }
+  
+  void FrameCache::enable_cache() 
+  {	
+  	cache_enabled = 1;
+  }
+  
+ 
+  void FrameCache::disable_cache() 
+  {
+  	cache_enabled = 0;
+  }
+  
+  void FrameCache::unlock_cache()
+  { 
+  	change_lock.unlock();
+  }
+  
+  void FrameCache::lock_cache()
+  { 
+  	change_lock.lock();
+  }
+  
+  inline int FrameCache::compare_with_frame(FrameCacheElement *element, 
+  					long frame_number, 
+  					int frame_layer,
+  					int frame_width,
+  					int frame_height,
+  					int frame_color_model)
+  {
+  	if (	element->frame_number == frame_number && 
+ 		element->frame_layer == frame_layer && 
+  		element->frame->get_w() == frame_width && 
+  		element->frame->get_h() == frame_height && 
+  		element->frame->get_color_model() == frame_color_model)
+  			return 1; 
+  		else
+  			return 0;
+  }
+  
+  FrameCacheTree::iterator FrameCache::find_element_byframe(long frame_number, int frame_layer, int frame_width, int frame_height, int frame_color_model)
+  {
+  	FrameCacheTree::iterator iterator = cache_tree.find(frame_number);
+ 	while (iterator != cache_tree.end() && iterator->first == frame_number)
+ 	{
+ 		if (compare_with_frame(iterator->second, 
+ 					frame_number, 
+ 					frame_layer,
+ 					frame_width,
+ 					frame_height,
+ 					frame_color_model))
+ 		{			
+ 			return iterator;
+ 		}
+ 		iterator++;
+ 	}
+  	return cache_tree.end();
+  }
+  
+  FrameCacheTree_ByTime::iterator FrameCache::find_element_bytime(long long frame_time_diff, long frame_number, int frame_layer, int frame_width, int frame_height, int frame_color_model)
+  {
+  	FrameCacheTree_ByTime::iterator iterator = cache_tree_bytime.find(frame_time_diff);
+    	while (iterator != cache_tree_bytime.end() && iterator->first == frame_time_diff)
+ 	{
+ 		if (compare_with_frame(iterator->second, 
+ 					frame_number, 
+ 					frame_layer,
+ 					frame_width,
+ 					frame_height,
+ 					frame_color_model))
+ 		{			
+ 			return iterator;
+ 		}
+ 		iterator++;
+ 	}
+  	return cache_tree_bytime.end();
+  }
+  
+   
+  // implicitly locks the class, needs to be unlocked after the call
+  // this is the best behaviour, everything else just complicates things and
+  // causes races (because you don't know the state of cache_enabled during the call).
+ VFrame *FrameCache::get_frame(long frame_number, int frame_layer, int frame_width, int frame_height, int frame_color_model, int force_cache)
+  {
+  
+  	change_lock.lock();
+  	if (!cache_enabled && !force_cache) return 0;
+  //	printf("Looking for - frame: %li, layer: %i, w: %i, h:%i, cm: %i\n", frame_number, frame_layer, frame_width, frame_height, frame_color_model);
+  	FrameCacheTree::iterator iterator= find_element_byframe(frame_number, 
+  								frame_layer,
+  								frame_width,
+  								frame_height,
+  								frame_color_model);
+  	// update timestamp in other tree
+  	if (iterator != cache_tree.end())
+  	{
+  		FrameCacheElement *cache_element = iterator->second;
+  		FrameCacheTree_ByTime::iterator iterator_bytime;
+  		// this tree node always exists
+  		iterator_bytime = find_element_bytime(cache_element->time_diff,
+  								frame_number, 
+  								frame_layer,
+  								frame_width,
+  								frame_height,
+  								frame_color_model);
+  		if (cache_element != iterator_bytime->second)
+  		{
+  			printf("FrameCache: Something severely wrong in the cache engine!! this: %p\n", this);
+  			dump();
+  			return 0;
+  		};
+ // 		printf("Cache hit - frame: %li, layer: %i, w: %i, h:%i, cm: %i\n", frame_number, frame_layer, frame_width, frame_height, frame_color_model);
+  		// delete & replace with new key
+  		cache_tree_bytime.erase(iterator_bytime);
+  		cache_element->time_diff = timer.get_difference();
+  		cache_tree_bytime.insert(std::pair<long long, FrameCacheElement *> (cache_element->time_diff, cache_element)); 
+  		return (cache_element->frame);
+  	};
+  	return 0;
+  } 
+ 
+ // Always puts the image into cache, even if cache_size is 0 - there is always at least one image in the cache
+ // if do_not_copy_frame is set, cache is locked after this function
+ // returns always 1
+ 
+ int FrameCache::add_frame(long frame_number, int frame_layer, VFrame *frame, int do_not_copy_frame, int force_cache) 
+  {
+  	
+  	if (!cache_enabled && !force_cache) return 0;
+  	change_lock.lock();
+  	
+  //	printf("%p, adding frame:  %li, layer: %i, w: %i, h:%i cm:%i\n",this, frame_number, frame_layer, frame->get_w(),frame->get_h(), frame->get_color_model());
+  	
+  	FrameCacheElement *cache_element = 0;
+ 
+ 	// what will be new size
+  	int64_t new_memory_size = frame->get_data_size();
+ 
+  	// currently cache size can only grow, not shrink
+  	while (memory_used + new_memory_size >= cache_size && memory_used > 0) 
+  	{
+ 		// delete the cache element from previous iteration
+ 		if (cache_element)
+ 			delete cache_element;
+ 
+ 		// if we cannot fit the new image into cache, exit
+ 		// new strategy: allways have one image in the cache - this is due to other read_frame function
+ 		// do not enable this code
+ //		if (memory_used == 0 && new_memory_size > cache_size) {
+ //			change_lock.unlock();
+ //			return 0;
+ //		}
+ 		// delete the element that wansn't accessed for the longest time
+  		FrameCacheTree_ByTime::iterator iterator_bytime = cache_tree_bytime.begin();
+  		cache_element = iterator_bytime->second;
+  		FrameCacheTree::iterator iterator = find_element_byframe(cache_element->frame_number,
+  									cache_element->frame_layer,
+  									cache_element->frame->get_w(),
+  									cache_element->frame->get_h(),
+  									cache_element->frame->get_color_model());
+  //	printf("Deleting oldest frame: - frame: %li, layer: %i, w: %i, h:%i, cm: %i\n", cache_element->frame_number, cache_element->frame_layer, cache_element->frame->get_w(), cache_element->frame->get_h(), cache_element->frame->get_color_model());
+ 		memory_used -= cache_element->frame->get_data_size();
+  		delete cache_element->frame;
+  		cache_tree.erase(iterator);
+    		cache_tree_bytime.erase(iterator_bytime);
+ 	}
+ 
+ 	if (!cache_element) // recycle cache element if possible
+ 		cache_element = new FrameCacheElement;
+  	
+  	if (do_not_copy_frame) 
+  	{
+  		cache_element->frame = frame;
+  	} else
+  	{
+  		cache_element->frame = new VFrame(0,
+  					frame->get_w(),
+  					frame->get_h(),
+  					frame->get_color_model());
+  		cache_element->frame->copy_from(frame);
+  	}
+ 	memory_used += cache_element->frame->get_data_size();
+  	cache_element->frame_layer = frame_layer;
+  	cache_element->frame_number = frame_number;
+  	cache_element->time_diff = timer.get_difference();
+ 
+ //	printf("Adding frame: - frame: %li, layer: %i, w: %i, h:%i, cm: %i\n", cache_element->frame_number, cache_element->frame_layer, cache_element->frame->get_w(), cache_element->frame->get_h(), cache_element->frame->get_color_model());
+ 	
+ //	printf("Memory used by cache: %p %lli\n", this, memory_used);
+  
+  // insert the same data into both trees under different keys
+  	
+  	cache_tree.insert(std::pair<long, FrameCacheElement *> (cache_element->frame_number, cache_element));
+  	cache_tree_bytime.insert(std::pair<long long, FrameCacheElement *> (cache_element->time_diff, cache_element)); 
+  	if (!do_not_copy_frame)
+ 		change_lock.unlock();
+ 	return 1;
+ }
+  
+  void FrameCache::dump() 
+ {	
+  	printf("Dump of frames' cache %p, cache_tree:\n", this);
+  	{
+  		FrameCacheTree::iterator iterator = cache_tree.begin();
+  		while (iterator != cache_tree.end()) {
+  			FrameCacheElement *cache_element = iterator->second;
+  			printf("%p, frame: %li, layer: %i, w: %i, h:%i, cm: %i, time_diff: %i\n", cache_element, cache_element->frame_number, cache_element->frame_layer, cache_element->frame->get_w(), cache_element->frame->get_h(), cache_element->frame->get_color_model(), cache_element->time_diff);
+  			iterator++;
+  		}
+  	}
+  	printf("cache_tree_bytime:\n", this);
+  	{
+  		FrameCacheTree_ByTime::iterator iterator = cache_tree_bytime.begin();
+  		while (iterator != cache_tree_bytime.end()) {
+  			FrameCacheElement *cache_element = iterator->second;
+  			printf("%p, frame: %li, layer: %i, w: %i, h:%i, cm: %i, time_diff: %li\n", cache_element, cache_element->frame_number, cache_element->frame_layer, cache_element->frame->get_w(), cache_element->frame->get_h(), cache_element->frame->get_color_model(), cache_element->time_diff);
+  			iterator++;
+  		}
+  	}
+  }
+ 
  
  File::File()
  {
  	cpus = 1;
  	asset = new Asset;
+ 	frames_cache = new FrameCache(0);     // this could possibly be avoided for write-files
  	reset_parameters();
  }
  
***************
*** 47,60 ****
  		delete temp_frame;
  	}
  
- 	if(return_frame)
- 	{
- 		delete return_frame;
- 	}
- 
  	close_file();
  	reset_parameters();
  	delete asset;
  }
  
  void File::reset_parameters()
--- 300,309 ----
  		delete temp_frame;
  	}
  
  	close_file();
  	reset_parameters();
  	delete asset;
+ 	delete frames_cache;
  }
  
  void File::reset_parameters()
