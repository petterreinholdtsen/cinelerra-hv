<html lang="en">
<head>
<title>Secrets of Cinelerra</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name=description content="Secrets of Cinelerra">
<meta name=generator content="makeinfo 4.0b">
<link href="http://texinfo.org/" rel=generator-home>
</head>

<body>
<p><hr>
Node:<a name="Top">Top</a>,
Next:<a rel=next href="#ABOUT%20CINELERRA">ABOUT CINELERRA</a>
<br>

<h1>BRIEF CONTENTS</h1>

<ul>
<li><a href="#ABOUT%20CINELERRA">ABOUT CINELERRA</a>: 
<li><a href="#INSTALLATION">INSTALLATION</a>: 
<li><a href="#CONFIGURATION">CONFIGURATION</a>: 
<li><a href="#THE%20MAIN%20WINDOWS">THE MAIN WINDOWS</a>: 
<li><a href="#LOADING%20AND%20SAVING%20FILES">LOADING AND SAVING FILES</a>: 
<li><a href="#NAVIGATING%20THE%20PROJECT">NAVIGATING THE PROJECT</a>: 
<li><a href="#EDITING">EDITING</a>: 
<li><a href="#USING%20EFFECTS">USING EFFECTS</a>: 
<li><a href="#SETTING%20PROJECT%20ATTRIBUTES">SETTING PROJECT ATTRIBUTES</a>: 
<li><a href="#COMPOSITING">COMPOSITING</a>: 
<li><a href="#KEYFRAMES">KEYFRAMES</a>: 
<li><a href="#CAPTURING%20MEDIA">CAPTURING MEDIA</a>: 
<li><a href="#EFFECT%20DESCRIPTIONS">EFFECT DESCRIPTIONS</a>: 
</ul>


<h1>Table of Contents</h1>
<ul>
<li><a href="#Top">BRIEF CONTENTS</a>
<li><a href="#ABOUT%20CINELERRA">ABOUT CINELERRA</a>
<ul>
<li><a href="#ABOUT%20THIS%20MANUAL">ABOUT THIS MANUAL</a>
</ul>
<li><a href="#INSTALLATION">INSTALLATION</a>
<li><a href="#CONFIGURATION">CONFIGURATION</a>
<ul>
<li><a href="#PLAYBACK">PLAYBACK</a>
<ul>
<li><a href="#AUDIO%20OUT">AUDIO OUT</a>
<li><a href="#VIDEO%20OUT">VIDEO OUT</a>
</ul>
<li><a href="#RECORDING">RECORDING</a>
<ul>
<li><a href="#AUDIO%20IN">AUDIO IN</a>
<li><a href="#VIDEO%20IN">VIDEO IN</a>
</ul>
<li><a href="#PERFORMANCE">PERFORMANCE</a>
<ul>
<li><a href="#RENDERFARM">RENDERFARM</a>
</ul>
<li><a href="#INTERFACE">INTERFACE</a>
</ul>
<li><a href="#THE%20MAIN%20WINDOWS">THE MAIN WINDOWS</a>
<li><a href="#LOADING%20AND%20SAVING%20FILES">LOADING AND SAVING FILES</a>
<ul>
<li><a href="#LOADING%20FILES">LOADING FILES</a>
<ul>
<li><a href="#SUPPORTED%20FILE%20FORMATS">SUPPORTED FILE FORMATS</a>
<li><a href="#INSERTION%20STRATEGY">INSERTION STRATEGY</a>
<li><a href="#LOADING%20MULTIPLE%20FILES">LOADING MULTIPLE FILES</a>
</ul>
<li><a href="#LOADING%20THE%20BACKUP">LOADING THE BACKUP</a>
<li><a href="#SAVING%20FILES">SAVING FILES</a>
<li><a href="#RENDERING%20FILES">RENDERING FILES</a>
<li><a href="#THE%20RENDER%20FARM">THE RENDER FARM</a>
</ul>
<li><a href="#NAVIGATING%20THE%20PROJECT">NAVIGATING THE PROJECT</a>
<ul>
<li><a href="#NAVIGATING%20THE%20PROGRAM%20WINDOW">NAVIGATING THE PROGRAM WINDOW</a>
<ul>
<li><a href="#THE%20INSERTION%20POINT">THE INSERTION POINT</a>
<li><a href="#THE%20IN%2fOUT%20POINTS">THE IN/OUT POINTS</a>
<li><a href="#USING%20LABELS%20IN%20THE%20PROGRAM%20WINDOW">USING LABELS IN THE PROGRAM WINDOW</a>
</ul>
<li><a href="#NAVIGATING%20THE%20VIEWER%20AND%20COMPOSITOR">NAVIGATING THE VIEWER AND COMPOSITOR</a>
<li><a href="#NAVIGATING%20THE%20RESOURCES">NAVIGATING THE RESOURCES</a>
<li><a href="#USING%20THE%20TRANSPORT%20CONTROLS">USING THE TRANSPORT CONTROLS</a>
</ul>
<li><a href="#EDITING">EDITING</a>
<ul>
<li><a href="#MANIPULATING%20TRACKS">MANIPULATING TRACKS</a>
<li><a href="#TWO%20SCREEN%20EDITING">TWO SCREEN EDITING</a>
<li><a href="#DRAG%20AND%20DROP%20EDITING">DRAG AND DROP EDITING</a>
<li><a href="#CUT%20AND%20PASTE%20EDITING">CUT AND PASTE EDITING</a>
<li><a href="#TRIMMING">TRIMMING</a>
</ul>
<li><a href="#USING%20EFFECTS">USING EFFECTS</a>
<ul>
<li><a href="#REALTIME%20EFFECTS">REALTIME EFFECTS</a>
<ul>
<li><a href="#REALTIME%20EFFECT%20TYPES">REALTIME EFFECT TYPES</a>
<li><a href="#EDITING%20REALTIME%20EFFECTS">EDITING REALTIME EFFECTS</a>
</ul>
<li><a href="#RENDERED%20EFFECTS">RENDERED EFFECTS</a>
<li><a href="#TRANSITIONS">TRANSITIONS</a>
</ul>
<li><a href="#SETTING%20PROJECT%20ATTRIBUTES">SETTING PROJECT ATTRIBUTES</a>
<li><a href="#COMPOSITING">COMPOSITING</a>
<ul>
<li><a href="#THE%20CAMERA%20AND%20PROJECTOR">THE CAMERA AND PROJECTOR</a>
<li><a href="#MASKS">MASKS</a>
<li><a href="#CROPPING">CROPPING</a>
<li><a href="#SAFE%20REGIONS">SAFE REGIONS</a>
<li><a href="#OVERLAY%20MODES">OVERLAY MODES</a>
<li><a href="#TRACK%20AND%20OUTPUT%20SIZES">TRACK AND OUTPUT SIZES</a>
</ul>
<li><a href="#KEYFRAMES">KEYFRAMES</a>
<ul>
<li><a href="#CURVE%20KEYFRAMES">CURVE KEYFRAMES</a>
<li><a href="#TOGGLE%20KEYFRAMES">TOGGLE KEYFRAMES</a>
<li><a href="#AUTOMATIC%20KEYFRAMES">AUTOMATIC KEYFRAMES</a>
<li><a href="#COMPOSITOR%20KEYFRAMES">COMPOSITOR KEYFRAMES</a>
<li><a href="#EDITING%20KEYFRAMES">EDITING KEYFRAMES</a>
</ul>
<li><a href="#CAPTURING%20MEDIA">CAPTURING MEDIA</a>
<ul>
<li><a href="#BATCHES">BATCHES</a>
<li><a href="#EDITING%20TUNER%20INFORMATION">EDITING TUNER INFORMATION</a>
</ul>
<li><a href="#EFFECT%20DESCRIPTIONS">EFFECT DESCRIPTIONS</a>
<ul>
<li><a href="#CHROMA%20KEY">CHROMA KEY</a>
</ul>
</ul>

<p><hr>
Node:<a name="ABOUT%20CINELERRA">ABOUT CINELERRA</a>,
Next:<a rel=next href="#INSTALLATION">INSTALLATION</a>,
Previous:<a rel=previous href="#Top">Top</a>,
Up:<a rel=up href="#Top">Top</a>
<br>

<h1>ABOUT CINELERRA</h1>

<p>There are two types of moviegoers: producers who create new content,
going back over their content at future points for further refinement,
and consumers who want to acquire the content and watch it.  Cinelerra
is not intended for consumers.  Cinelerra has many features for
uncompressed content, high resolution processing, and compositing, with
very few shortcuts.  Producers need these features because of the need
to retouch many generations of footage with alterations to the format,
which makes Cinelerra very complex. There are many more standard tools
for consumers like MainActor, Kino, or Moxy, which you should consider
before using Cinelerra.

<p>In 1996 our first editor came out: Broadcast 1.0.  It was just a window
with a waveform in it, it could cut and paste stereo audio waveforms on
a UNIX box, except unlike other audio editors it could handle files up
to 2 gigabytes with only 64 megs of RAM.  That was a feature normally
only accessible to the highest end professional audio houses.

<p>In 1997 Broadcast 1.0 was replaced by Broadcast 2.0.  This time the
window had a menubar, patchbay, console, and transport control. 
Broadcast 2.0 still only handled audio but this time it handled
unlimited tracks, and it could perform effects on audio and save the
resulting waveform to disk.  More notably a few effects could be
performed as the audio was playing back, in realtime.  A user could mix
unlimited numbers of tracks, adjust fade, pan, and EQ, and hear the
result instantly.   Amazingly this real time tweeking is still
unavailable on most audio programs.

<p>But Broadcast 2.0 still didn't handle video and it wasn't very graceful
at audio either.  In 1999 video broke into the story with Broadcast
2000.  This iteration of the Broadcast series could do wonders with
audio and offered a pretty good video feature set.  It could edit video
files up to 64 terabytes.  It could do everything Broadcast 2.1 did
with audio except now all effects for video and audio could be chained
and performed on the fly, with instant feedback as a user tweeked
parameters during playback.  Broadcast 2000 made it very easy to do a
lot of processing and editing on video and audio that would otherwise
involve many hours setting up command line sequences and writing to
disk. For a time it seemed as if the original dream of immersive movie
making for everyone regardless of income level had arrived.

<p>Later on Broadcast 2000 began to come short.  Its audio was pretty
graceful.  Its video was graceful if you knew how to use it
efficiently, but quality issues and new user interface techniques were
emerging.  Broadcast 2000 kept the audio interface from its ancestors,
which didn't apply well to video.  Users likewise were maturing.  No
longer would it be sufficient to just edit video on a UNIX box.  Most
users expected on UNIX the same thing they got in Win or Mac. In mid
2000 designs for a Broadcast 2000 replacement were drafted.  The
Broadcast name was officially retired from the series and the software
would now be called Cinelerra.  Cinelerra would allow users to
configure certain effects in much less time than required with
Broadcast 2000.  It would begin to emulate some of the features found
in Win and Mac software while not attempting to become a clone.  It's
interface would be designed for video from the ground up, while
supplementing that with the Broadcast audio interface.  As always,
quality improvements would happen.

<ul>
<li><a href="#ABOUT%20THIS%20MANUAL">ABOUT THIS MANUAL</a>: 
</ul>

<p><hr>
Node:<a name="ABOUT%20THIS%20MANUAL">ABOUT THIS MANUAL</a>,
Up:<a rel=up href="#ABOUT%20CINELERRA">ABOUT CINELERRA</a>
<br>

<h2>ABOUT THIS MANUAL</h2>

<p>After many years of searching for the perfect documentation format
we've arrived at TexInfo.  This format can be converted to HTML,
printed, automatically indexed, but most importantly is not bound to
any commercial word processor.  Documents written in Texinfo will be
readable as long as there's a C compiler.

<p>There are no screenshots in this manual.  Screenshots become obsolete
quickly and as a result confuse the users.  What looks one way in a
screenshot will always look different in the real program because the
real program and the manual are always evolving, never perfectly
synchronized.  It is true that manuals should have screenshots, but our
objective in omitting screenshots is to keep the software costs minimal
so you don't have to pay for it.  That includes additional labor to
synchronize the manual with the software.

<p>In addition to telling you the basic editing features of Cinelerra this
manual covers tricks that won't be described anywhere else.  We're
going to try to come up with certain things you can do with Cinelerra
that you wouldn't think of on your own.

<p><hr>
Node:<a name="INSTALLATION">INSTALLATION</a>,
Next:<a rel=next href="#CONFIGURATION">CONFIGURATION</a>,
Previous:<a rel=previous href="#ABOUT%20CINELERRA">ABOUT CINELERRA</a>,
Up:<a rel=up href="#Top">Top</a>
<br>

<h1>INSTALLATION</h1>

<p>The Cinelerra package contains Cinelerra, Mix2000, Mplex, and XMovie,
along with standalone libraries for various functions.  All these
programs are useful and in most cases they're the only free programs
available for dealing with uncompressed, high resolution movies.

<p>All of these programs tie into the same code base.  Updates in one area
of the code base usually affect everything else so everything would
have to be downloaded again even if one thing changed.  By including
everything in one package you can be instantly updated for movie making
after one download.

<p>The purpose of the various programs is as follows:

<ul>

<li>
Cinelerra - capturing, editing and production of material

<li>
Mix2000 - higher resolution volume controller than the standard Linux
volume controls.

<li>
MPlex - Multiplexing of MPEG elementary streams.

<li>
XMovie - Standalone player for all the formats Cinelerra exports.

<li>
mpeg3toc - Utility for indexing and reading MPEG files.

</ul>

<p>We try to include all the dependancies because of the difficulty in
tracking them down.  Furthermore, the versions of some of the
dependancies Cinelerra requires differ from the versions other
utilities may require, making it impossible to coexist on the same
system without static inclusion.

<p>Cinelerra is best installed by downloading an RPM and running

<pre>rpm -U --force --nodeps hvirtual*.rpm
</pre>

<p>on a RedHat system.

<p>On systems which don't support RPM look for a utility called
<em>rpm2cpio</em>.  Download a Cinelerra RPM and from the /
directory run

<pre>rpm2cpio hvirtual*.rpm | cpio -i --make-directories
</pre>

<p>It should be noted that the compiler used in building Cinelerra
binaries is the free GNU compiler and although it can reorder
instructions for Pentium I and use some the of Pentium II branch
instructions it's 12 years behind most modern CPUs.  You can try
different compilers and optimization flags by compiling the source.

<p>Compiling the source is hard and there's no warranty if the source code
fails to compile, but the method for compiling starts by downloading
the source code and decompressing.

<pre>tar jxf hvirtual*.tar.bz2
</pre>

<p>Enter the hvirtual directory

<pre>cd hvirtual
</pre>

<p>and set some environment variables.  For Pentium II use:

<pre>export CFLAGS='-O3 -march=i686 -fmessage-length=0 -funroll-all-loops -fomit-frame-pointer -malign-loops=2 -malign-jumps=2 -malign-functions=2 -I/usr/local/include'
</pre>

<p>For Pentium I and old AMD's use:

<pre>export CFLAGS='-O3 -fmessage-length=0 -funroll-all-loops -fomit-frame-pointer -malign-loops=2 -malign-jumps=2 -malign-functions=2 -I/usr/local/include'
</pre>

<p>Then run

<pre>make
</pre>

<p>The make procedure should run through all the directories and put
binaries in the <em>i686</em> directories.  When we originally supported
Alpha it was convenient to compile Alpha and i686 binaries
simultaneously, in different directories so all the binaries are put in
i686 directories.

<p>Once finished run

<pre>make install
</pre>

<p>to install the binaries.  The output is put in the following directories:

<ul>
<li>Executables -&gt;/usr/bin
<li>Plugins  -&gt;/usr/lib/cinelerra
</ul>

<p>The main binaries are the Cinelerra, XMovie, Mix2000 executables and
several utilities for reading MPEG transport streams.

<p>Run Cinelerra by running

<pre>/usr/bin/cinelerra
</pre>

<p><hr>
Node:<a name="CONFIGURATION">CONFIGURATION</a>,
Next:<a rel=next href="#THE%20MAIN%20WINDOWS">THE MAIN WINDOWS</a>,
Previous:<a rel=previous href="#INSTALLATION">INSTALLATION</a>,
Up:<a rel=up href="#Top">Top</a>
<br>

<h1>CONFIGURATION</h1>

<p>Because of the variety of uses, Cinelerra cannot be run optimally
without some intimate configuration for your specific needs. Very few
parameters are adjustible at compile time.  Runtime configuration is
the only option for most configuration because of the multitude of
parameters.

<p>Go to <em>settings-&gt;preferences</em> and run through the options.

<ul>
<li><a href="#PLAYBACK">PLAYBACK</a>: 
<li><a href="#RECORDING">RECORDING</a>: 
<li><a href="#PERFORMANCE">PERFORMANCE</a>: 
<li><a href="#INTERFACE">INTERFACE</a>: 
</ul>

<p><hr>
Node:<a name="PLAYBACK">PLAYBACK</a>,
Next:<a rel=next href="#RECORDING">RECORDING</a>,
Up:<a rel=up href="#CONFIGURATION">CONFIGURATION</a>
<br>

<h2>PLAYBACK</h2>

<ul>
<li><a href="#AUDIO%20OUT">AUDIO OUT</a>: 
<li><a href="#VIDEO%20OUT">VIDEO OUT</a>: 
</ul>

<p><hr>
Node:<a name="AUDIO%20OUT">AUDIO OUT</a>,
Next:<a rel=next href="#VIDEO%20OUT">VIDEO OUT</a>,
Up:<a rel=up href="#PLAYBACK">PLAYBACK</a>
<br>

<h3>AUDIO OUT</h3>

<p>These determine what happens when you play sound from the timeline.

<ul>

<li>SAMPLES TO READ FROM DISK

<p>Cinelerra uses a pipeline for rendering audio. The first stage is
reading large chunks of audio from disk, the samples to read from
disk.  This is followed by processing small fragments in a virtual
console.

</p><li>SAMPLES TO SEND TO CONSOLE:

<p>The second stage is rendering small fragments through the virtual
console to the sound driver. A larger value here causes more latency
when you change mixing parameters but gives more reliable playback.

<p>Some sound drivers don't allow changing of the console fragment so
latency is unchanged no matter what this value is.

</p><li>
VIEW FOLLOWS PLAYBACK

<p>Causes the timeline window to scroll when the playback cursor moves out
of view.  This can bog down the X Server.

</p><li>USE SOFTWARE FOR POSITIONING INFORMATION

<p>Most soundcards and sound drivers don't give reliable information on
the number of samples the card has played. When playing video you need
this information for synchronization. This option causes the sound
driver to be ignored and a software timer to be used for
synchronization.

</p><li>AUDIO PLAYBACK IN REALTIME:

<p>Back in the days when 150Mhz was the maximum, this allowed
uninterrupted playback on heavy loads. Now you'll probably only need it
for playing video and audio when the load is to high for uninterrupted
audio.

</p><li>AUDIO DRIVER

<p>There are many sound drivers for Linux.  This allows selecting one and
setting parameters specific to it.  Some of the common parameters for a
sound driver are

<ul>

<li>DEVICE PATH

<p>Usually a file in the <em>/dev/</em> directory which controls the
device.

</p><li>
BITS

<p>The number of bits of precision Cinelerra should set the device for. 
This sometimes has a figuritive meaning.  Some sound drivers need to be
set to 32 bits to perform 24 bit playback and won't play anything when
set to 24 bits.  Some sound drivers need to be set to 24 bits for 24
bit playback.

</p><li>
CHANNELS

<p>The number of channels Cinelerra should set the device for.  Regardless
of the number of channels in the project, the number of channels set
here will be written to the device.  When this is set to 2 and the
project has 1 channel you'll hear sound through the left speaker and
not centered as expected for a monaural project.  When this is set to 1
and the project has 2 channels you'll hear the left channel centered
and not 2 channels mixed together.

</ul>
</ul>

<p><hr>
Node:<a name="VIDEO%20OUT">VIDEO OUT</a>,
Previous:<a rel=previous href="#AUDIO%20OUT">AUDIO OUT</a>,
Up:<a rel=up href="#PLAYBACK">PLAYBACK</a>
<br>

<h3>VIDEO OUT</h3>

<p>These determine what happens when you play video from the timeline.

<ul>

<li>
FRAMERATE ACHIEVED

<p>The number of frames per second being
displayed during playback.

</p><li>
SCALING EQUATION

<p>The algorithm used in all video resizing in
the virtual console.  This doesn't affect scaling to the size of the
compositor window.

<ul>

<li>NEAREST NEIGHBOR ENLARGE AND REDUCE

<p>lowest but fastest
quality.  Produces jagged edges and uneven motion.

</p><li>
BICUBIC ENLARGE AND BILINEAR REDUCE

<p>highest but slowest
quality.  For enlarging a bicubic interpolation is used, which blurs
slightly but doesn't reveal stair steps.  For reduction a bilinear
interpolation is used, which produces very sharp images and reduces
noise.  The bilinear reduced images can be sharpened with a sharpen
effect with less noise than a normal sized image.

</p><li>
BILINEAR ENLARGE AND BILINEAR REDUCE

<p>when slight enlargement
is needed a bilinear enlargement looks better than a bicubic
enlargement.

</ul>

</p><li>
PRELOAD BUFFER FOR QUICKTIME

<p>The Quicktime/AVI decoder can
handle CDROM sources better when this is around 1000000.  This reduces
the amount of seeking.  For normal use this should be 0.

</p><li>
VIDEO DRIVER

<p>Normally video on the timeline goes to the
compositor window during continuous playback and when the insertion
point is repositioned.  Instead of sending video to the Compositor
window the video driver can be set to send video to another output
device during continuous playback.  This doesn't affect where video
goes when the insertion point is repositioned, however.

<p>Various parameters are given for Video Driver depending on the driver.

<ul>

<li>
DISPLAY

<p>The is intended for dual monitor
displays.  Depending on the value of Display, the Compositor window
will appear on a different monitor from the rest of the windows.

</p><li>
DEVICE PATH

<p>Usually a file in the <em>/dev/</em> directory
which controls the device.

</p><li>
SWAP FIELDS

<p>Make the even lines odd and the odd lines even
when sending to the device.  On an NTSC or 1080i monitor the fields may
need to be swapped to prevent jittery motion.

</p><li>
OUTPUT CHANNEL

<p>Devices with multiple outputs may need a
specific connector to send video on.

</p><li>
PORT

<p>The IEEE1394 standard specifies something known as the
<em>port</em>.  This is probably the firewire card number in the system
to use.

</p><li>
CHANNEL

<p>The IEEE1394 standard specifies something known as the
<em>channel</em>.  For DV cameras it's always <em>63</em>.

</ul>

</ul>

<p><hr>
Node:<a name="RECORDING">RECORDING</a>,
Next:<a rel=next href="#PERFORMANCE">PERFORMANCE</a>,
Previous:<a rel=previous href="#PLAYBACK">PLAYBACK</a>,
Up:<a rel=up href="#CONFIGURATION">CONFIGURATION</a>
<br>

<h2>RECORDING</h2>

<ul>
<li><a href="#AUDIO%20IN">AUDIO IN</a>: 
<li><a href="#VIDEO%20IN">VIDEO IN</a>: 
</ul>

<p><hr>
Node:<a name="AUDIO%20IN">AUDIO IN</a>,
Next:<a rel=next href="#VIDEO%20IN">VIDEO IN</a>,
Up:<a rel=up href="#RECORDING">RECORDING</a>
<br>

<h3>AUDIO IN</h3>

<p>These determine what happens when you record audio.

<ul>
<li>
RECORD DRIVER

<p>This is used for recording audio in the Record window.  It may be
shared with the Record Driver for video if the audio and video are
wrapped in the same stream.  It takes variable parameters depending on
the driver.  The parameters have the same meaning as they do for
playback.

<ul>
<li>
DEVICE PATH

<p>Usually a file in the <em>/dev/</em> directory which controls the
device.

</p><li>
BITS

<p>The number of bits of precision Cinelerra should set the device for. 
This sometimes has a figuritive meaning.  Some sound drivers need to be
set to 32 bits to perform 24 bit recording and won't record anything
when set to 24 bits.  Some sound drivers need to be set to 24 bits for
24 bit recording.

</p><li>CHANNELS

<p>The number of channels Cinelerra should set the device for.  Regardless
of the number of channels in the record operation, the number of
channels set here will be read from the device.  When this is set to 2
and the record operation has 1 channel you'll record the left speaker
and not a mix of the left and right speakers as expected for a monaural
project.  When this is set to 1 and the project has 2 channels you'll
record the left and right channels mixed into the left speaker and not
1 channel spead across two speakers.

</ul>

</p><li>
SAMPLES TO WRITE AT A TIME

<p>Audio is first read in small fragments from the device.  Many small
fragments are combined into a large fragment before writing to disk. 
The disk writing process is done in a different thread.  The value here
determines how large the combination of fragments is for each disk
write.

</p><li>
SAMPLE RATE FOR RECORDING

<p>Regardless of what the project settings are.  This is the sample rate
used for recording.  This should be the highest the audio device
supports.

</ul>

<p><hr>
Node:<a name="VIDEO%20IN">VIDEO IN</a>,
Previous:<a rel=previous href="#AUDIO%20IN">AUDIO IN</a>,
Up:<a rel=up href="#RECORDING">RECORDING</a>
<br>

<h3>VIDEO IN</h3>

<p>These determine what happens when you record video.

<ul>
<li>
RECORD DRIVER

<p>This is used for recording video in the Record window.  It may be
shared with the Record Driver for audio if the audio and video are
wrapped in the same stream.  It takes variable parameters depending on
the driver.  The parameters have the same meaning as they do for
playback.

</p><li>
FRAMES TO RECORD TO DISK AT A TIME

<p>Frames are recorded in a pipeline.  First frames are buffered in the
device.  Then they're read into a larger buffer for writing to disk. 
The disk writing is done in a different thread as the device reading. 
For certain codecs the disk writing uses multiple processors.  This
value determines how many frames are written to disk at a time.

</p><li>
FRAMES TO BUFFER IN DEVICE

<p>The number of frames to store in the device before reading.  This
determines how much latency there can be in the system before frames
are dropped.

</p><li>USE SOFTWARE FOR POSITIONING INFORMATION

<p>Video uses audio for

<p>synchronization but most soundcards don't give accurate position
information.  This calculates an estimation of audio position in
software instead of the hardware for synchronization.

</p><li>
SYNC DRIVES AUTOMATICALLY

<p>For high bitrate recording the drives may be fast enough to store the
data but Linux may wait several minutes and stall as it writes several
minutes of data at a time.  This forces Linux to flush its buffers
every second instead of every few minutes and produce slightly better
realtime behavior.

</p><li>
SIZE OF CAPTURED FRAME

<p>This is the size of the frames recorded.  It is independant of the
project frame size because most video devices only record a fixed frame
size.  If the frame size given here isn't supported by the device it
might crash Cinelerra.

</p><li>FRAME RATE FOR RECORDING

<p>The frame rate recorded is different from the project settings.  This
sets the recorded frame rate.

</ul>

<p><hr>
Node:<a name="PERFORMANCE">PERFORMANCE</a>,
Next:<a rel=next href="#INTERFACE">INTERFACE</a>,
Previous:<a rel=previous href="#RECORDING">RECORDING</a>,
Up:<a rel=up href="#CONFIGURATION">CONFIGURATION</a>
<br>

<h2>PERFORMANCE</h2>

<p>You'll spend most of your time configuring this section.

<ul>
<li><a href="#RENDERFARM">RENDERFARM</a>: 
</ul>

<ul>

<li>
INDEX FILES GO HERE

<p>Back in the days when 4 MB/sec was unearthly speed for a hard drive,
index files were introduced to speed up drawing the audio tracks.  This
option determines where index files are placed on the hard drive.

</p><li>
SIZE OF INDEX FILE

<p>Determines the size of an index file. Larger index sizes allow smaller
files to be drawn faster while slowing down the drawing of large files. 
Smaller index sizes allow large files to be drawn faster while slowing
down small files.

</p><li>
NUMBER OF INDEX FILES TO KEEP

<p>To keep the index directory from becoming unruly, old index files are
deleted. This determines the maximum number of index files to keep in
the directory.

</p><li>
DELETE ALL INDEXES

<p>When you change the index size or you want to clean out excessive index
files, this deletes all the index files.

</p><li>CACHE ITEMS

<p>To speed up rendering, several assets are kept open simultaneously. 
This determines how many are kept open.  A number too large may exhaust
your memory pretty fast and result in a crash.  A number too small may
result in slow playback as assets need to be reopened more frequently.

</p><li>
SECONDS TO PREROLL RENDERS

<p>Some effects need a certain amount of time to settle in.  This sets a
number of seconds to render without writing to disk before the selected
region is rendered.  When using the renderfarm you'll sometimes need to
preroll to get seemless transitions between the jobs.  Every job in a
renderfarm is prerolled by this value.

</p><li>
FORCE SINGLE PROCESSOR USE

<p>Cinelerra tries to use all processors on the system by default but
sometimes you'll only want to use one processor, like in a renderfarm
client.  This forces only one processer to be used.  The operating
system, however, usually uses the second processor anyway for disk
access so this option is really a 1.25 processor mode. </ul>

<p><hr>
Node:<a name="RENDERFARM">RENDERFARM</a>,
Up:<a rel=up href="#PERFORMANCE">PERFORMANCE</a>
<br>

<h3>RENDERFARM</h3>

<p>To use the renderfarm set these options.  Ignore them for a standalone
system

<ul>

<li>
USE RENDER FARM FOR RENDERING

<p>When selected, all the
<em>file-&gt;render</em> operations use the renderfarm.

</p><li>
NODES

<p>Displays all the nodes on the renderfarm and which ones are active.

<p>Nodes are added by entering the host name of the node, verifying the
value of <em>port</em> and hitting <em>add node</em>.

<p>Computer freaks may be better off editing the
<em>~/.bcast/.Cinelerra_rc</em> file than this if they have hundreds of
nodes.  Remember that .Cinelerra_rc is overwritten whenever a copy of
Cinelerra exits.

<p>Select the <em>ON</em> column to activate and deactivate nodes once they
are created.

<p>Nodes may be edited by highlighting a row and hitting <em>replace
node</em>.

</p><li>
HOSTNAME

<p>Edit the hostname of an existing node or enter the hostname of a new
node here.

</p><li>
PORT

<p>Edit the port of an existing node or enter the port of a new node here.

</p><li>
REPLACE NODE

<p>When editing an existing node, hit this to commit the changes to
<em>HOSTNAME</em> and <em>PORT</em>.  The changes won't be committed if you
don't hit this buttoin.

</p><li>
ADD NODE

<p>Create a new node with the <em>HOSTNAME</em> and <em>PORT</em> settings.

</p><li>
DELETE NODE

<p>Deletes whatever node is highlighted in the <em>NODES</em> list.

</p><li>
SORT NODES

<p>Sorts the <em>NODES</em> list based on the hostname.

</p><li>
FILESYSTEM PREFIX ON REMOTE NODES

<p>Sets the relative location of all the assets on the nodes.  If the
assets are in <em>/mov</em> on the master and the master filesystem is
mounted under <em>/mnt</em> on the nodes, the filesystem prefix should be
<em>/mnt</em>.  Ideally the assets should appear under the same directory
on the nodes as the master.  In this case the filesystem prefix can be
<em>/</em>.

<p>You don't have to mount a shared filesystem on remote nodes.  If the
shared filesystem is replicated somewhere on the slave node's hard
drive, Cinelerra will read all the assets from the node's hard drive
and write the output to the node's hard drive, and you won't need a
very fast network.  This is much more difficult to pull off but it's an
option for really slow networks.

<p>You don't have to specify a file on the master node's filesystem as the
output file.  If the output file is specified in some other directory
on the slave node hard drive Cinelerra will read assets from the master
filesystem but write to the node's hard drive.  Thus you have a way of
rendering across an asymetric network.

</p><li>
TOTAL JOBS TO CREATE

<p>Determines the number of jobs to dispatch to the renderfarm.  The more
jobs you create, the more finely balanced the renderfarm becomes.

<p>Determine the total jobs to create by multiplying the number of nodes
including the master node by some number.  Multiply them by 1 to have
one job dispatched for every node.  Multiply them by 3 to have 3 jobs
dispatched for every node.  If you have 10 slave nodes and one master
node, specify 33 to have a well balanced renderfarm.

</ul>

<p><hr>
Node:<a name="INTERFACE">INTERFACE</a>,
Previous:<a rel=previous href="#PERFORMANCE">PERFORMANCE</a>,
Up:<a rel=up href="#CONFIGURATION">CONFIGURATION</a>
<br>

<h2>INTERFACE</h2>

<p>These parameters affect purely how the user interface works.

<ul>

<li>USE HOURS:MINUTES:SECONDS.XXX

<p>Various representations of time are given.  Select the most convenient
one.  The time representation can also be changed by <em>CTRL</em>
clicking on the time ruler.

</p><li>USE THUMBNAILS

<p>The Resource Window displays thumbnails of assets by default.  This can
take a long time to set up.  This option disables the thumbnails.

</p><li>CLICKING IN/OUT POINTS DOES WHAT

<p>Cinelerra not only allows you to perform editing by dragging in/out
points but also defines three seperate operations which occur when you
drag an in/out point. For each mouse button you select the behavior in
this window. The usage of each editing mode is described in editing.

</p><li>MIN DB FOR METER

<p>Some sound sources have a lower noise threshold than others. 
Everything below the noise threshold is meaningless.  This option sets
the meters to clip below a certain level.  Consumer soundcards usually
bottom out at -65.  Professional soundcards bottom out at -90.

</p><li>FORMAT FOR METER

<p>This option allows you to select the format for all the VU meters. If
you're a CS major select percentage and if you're a EE major select DB. 
With that, be aware all levels in Cinelerra are input as DB.

</p><li>THEME

<p>Cinelerra supports variable themes.  Select one here and restart
Cinelerra to see it.

</ul>

<p><hr>
Node:<a name="THE%20MAIN%20WINDOWS">THE MAIN WINDOWS</a>,
Next:<a rel=next href="#LOADING%20AND%20SAVING%20FILES">LOADING AND SAVING FILES</a>,
Previous:<a rel=previous href="#CONFIGURATION">CONFIGURATION</a>,
Up:<a rel=up href="#Top">Top</a>
<br>

<h1>THE MAIN WINDOWS</h1>

<p>When Cinelerra first starts, you'll get four main windows.  Hitting
<em>CTRL-w</em> in any window closes it.

<ul>

<li>Viewer

<p>In here you'll scrub around source media and clips, selecting regions
to paste into the project.  Operations done in the viewer affect a
temporary EDL or a clip but not the timeline.

</p><li>Compositor

<p>This window displays the output of the timeline.  It's the interface
for most compositing operations or operations that affect the
appearance of the timeline output.  Operations done in the Compositor
affect the timeline but don't affect clips.

</p><li>Program

<p>This contains the timeline and the entry point for all menu driven
operations.  The timeline consists of a vertical stack of tracks with
horizontal representation of time.  This defines the output of
rendering operations and what is saved when you save files.

</p><li>Resources

<p>Effects, transitions, clips, and assets are accessed here.  Most of the
resources are inserted into the project by dragging them out of the
resource window.  Management of resource allocation is also performed
here.

</ul>

<p>Under the <em>Window</em> menu you'll find options affecting the main
windows.  <em>default positions</em> repositions all the windows to a 4
screen editing configuration.  On dual headed displays, the
<em>default positions</em> operation fills only one monitor with windows.

<p>An additional window, the <em>levels window</em> can be brought up from
the <em>Window</em> menu.  The <em>levels</em> window displays the output
audio levels after all mixing is done.

<p><hr>
Node:<a name="LOADING%20AND%20SAVING%20FILES">LOADING AND SAVING FILES</a>,
Next:<a rel=next href="#NAVIGATING%20THE%20PROJECT">NAVIGATING THE PROJECT</a>,
Previous:<a rel=previous href="#THE%20MAIN%20WINDOWS">THE MAIN WINDOWS</a>,
Up:<a rel=up href="#Top">Top</a>
<br>

<h1>LOADING AND SAVING FILES</h1>

<ul>
<li><a href="#LOADING%20FILES">LOADING FILES</a>: 
<li><a href="#LOADING%20THE%20BACKUP">LOADING THE BACKUP</a>: 
<li><a href="#SAVING%20FILES">SAVING FILES</a>: 
<li><a href="#RENDERING%20FILES">RENDERING FILES</a>: 
<li><a href="#THE%20RENDER%20FARM">THE RENDER FARM</a>: 
</ul>

<p><hr>
Node:<a name="LOADING%20FILES">LOADING FILES</a>,
Next:<a rel=next href="#LOADING%20THE%20BACKUP">LOADING THE BACKUP</a>,
Up:<a rel=up href="#LOADING%20AND%20SAVING%20FILES">LOADING AND SAVING FILES</a>
<br>

<h2>LOADING FILES</h2>

<p>All data that you work with in Cinelerra is acquired either by
<em>recording from a device</em> or by <em>loading from disk</em>.  This
section describes loading.

<p>The loading and playing of files is just as you would expect. Just go
to <em>file-&gt;Load</em>, select a file for loading, and hit <em>ok</em>. Hit
the forward play button and it should start playing, regardless of
whether a progress bar has popped up.

<p>Another way to load files is to pass the filenames as arguments on the
command line.  This creates new tracks for every file and starts the
program with all the arguments loaded.

<p>If the file is a still image, the project's attributes are not changed
and the first frame of the track becomes the image.  If the file has
audio, Cinelerra may build an index file for it to speed up drawing. 
You can edit and play the file while the index file is being built.

<ul>
<li><a href="#SUPPORTED%20FILE%20FORMATS">SUPPORTED FILE FORMATS</a>: 
<li><a href="#INSERTION%20STRATEGY">INSERTION STRATEGY</a>: 
<li><a href="#LOADING%20MULTIPLE%20FILES">LOADING MULTIPLE FILES</a>: 
</ul>

<p><hr>
Node:<a name="SUPPORTED%20FILE%20FORMATS">SUPPORTED FILE FORMATS</a>,
Next:<a rel=next href="#INSERTION%20STRATEGY">INSERTION STRATEGY</a>,
Up:<a rel=up href="#LOADING%20FILES">LOADING FILES</a>
<br>

<h3>SUPPORTED FILE FORMATS</h3>

<p>The format of the file affects what Cinelerra does with it.  Some
formats replace all the project settings.  Some just insert data with
existing project settings.  If your project sample rate is 48khz and
you load a sound file with 96khz, you'll still be playing it at
48khz.   XML files, however, replace the project settings.  If you load
an XML file at 96khz and the current project sample rate is 48khz,
you'll change it to 96khz.  Supported file formats are currently:

<ul>
<li>WAV
<li>PCM
<li>AIFF
<li>Uncompresed Quicktime

<p>Quicktime is not the standard for UNIX but we use it because it's well
documented.  All of the Quicktime movies on the internet are
compressed.  Cinelerra doesn't support compressed Quicktime movies. 
Most of the Quicktime footage dealt with in Cinelerra is generated by
Cinelerra either recording from a device or rendering.  The best
Quicktime settings to use are JPEG video and twos audio.

</p><li>JPEG, PNG, TIFF, TGA sequences

<p>Cinelerra generates a special table of contents file when you render an
image sequence.  You can either select every image file to load or
select the table of contents when the rendering is done.  Selecting the
table of contents is faster and doesn't fill up the resource window
with thousands of images.

</p><li>JPEG, PNG, TIFF, TGA still images

<p>When loaded, the image takes up one frame in length and doesn't change
the project attributes.

</p><li>AVI with mp3 audio and MPEG-4 video

<li>MPEG 1, 2 video

<p>You need to run <em>mpeg3toc</em> to generate a table of contents for
these, then load the table of contents.  If you want to edit a DVD,
find the corresponding <em>ifo</em> file for the program of interest and run

<pre>mpeg3toc /cdrom/video_ts/vts_01_0.ifo dvd.toc
</pre>

<p>or something similar.  Then load <em>dvd.toc</em>.  This allows frame
accurate editing where none would be possible otherwise.

</p><li>MPEG program streams and transport streams

<p>You need to run <em>mpeg3toc</em> on these just like MPEG 1,2 video. 
Program and transport streams are structured into multiple tracks. 
Each track can be video or audio.  Each audio track can have 1-6
channels.  Cinelerra converts each channel of audio into a track, so
for MPEG streams with multiple tracks, the tracks will be flattened.

</p><li>MPEG audio layer II, III

<p>These can be loaded directly with no table of contents.  Variable
bitrate streams may need a table of contents but are playable without
it.

</p><li>AC3 audio

<li>XML

<p>These are generated by Cinelerra for storing edit lists.  They change
project attributes when loaded.

</ul>

<p><hr>
Node:<a name="INSERTION%20STRATEGY">INSERTION STRATEGY</a>,
Next:<a rel=next href="#LOADING%20MULTIPLE%20FILES">LOADING MULTIPLE FILES</a>,
Previous:<a rel=previous href="#SUPPORTED%20FILE%20FORMATS">SUPPORTED FILE FORMATS</a>,
Up:<a rel=up href="#LOADING%20FILES">LOADING FILES</a>
<br>

<h3>INSERTION STRATEGY</h3>

<p>Usually three things happen when you load a file.  First the existing
project is cleared from the screen, second the project's attributes are
changed to match the file's, and finally the new file's tracks are
created in the timeline.

<p>But Cinelerra lets you change what happens when you load a file.

<p>In the file selection box go to the <em>Insertion strategy</em> box and
select it.  Each of these options loads the file a different way.

<ul>

<li>Replace current project

<p>All tracks in the current project are deleted and new tracks are
created to match the source.  Project attributes are only changed when
loading XML.  If multiple files are selected it adds new tracks for
every file.

</p><li>Replace current project and concatenate tracks

<p>Same as replace current project except if multiple files are selected
it concatenates the tracks of every file after the first.

</p><li>Append in new tracks

<p>The current project is not deleted and new tracks are created for the
source.

</p><li>Concatenate to existing tracks

<p>The current project is not deleted and new files are concatenated to
the existing tracks.

</p><li>Paste at insertion point

<p>The file is pasted in like a normal paste operation.

</p><li>Create new resources only

<p>The timeline is unchanged and new resources are created in the Resource
Window.

</ul>

<p>The insertion strategy is a recurring option in many of Cinelerra's
functions.  In each place the options do the same thing.  With these
options you can almost do all your editing by loading files.

<p>If you load files by passing command line arguments to Cinelerra, the
files are loaded with <em>Replace current project</em> rules.

<p><hr>
Node:<a name="LOADING%20MULTIPLE%20FILES">LOADING MULTIPLE FILES</a>,
Previous:<a rel=previous href="#INSERTION%20STRATEGY">INSERTION STRATEGY</a>,
Up:<a rel=up href="#LOADING%20FILES">LOADING FILES</a>
<br>

<h3>LOADING MULTIPLE FILES</h3>

<p>In the file selection box go to the list of files.  Select a file.  Go
to another file and select it while holding down <em>CTRL</em>.  This
selects one additional file.  Go to another file and select it while
holding down <em>SHIFT</em>.  This selects every intervening file.  This
behavior is available in most every list box.

<p>Select a bunch of mp3 files and <em>Replace current project and
concatenate tracks</em> in the insertion strategy to create a song
playlist.

<p><hr>
Node:<a name="LOADING%20THE%20BACKUP">LOADING THE BACKUP</a>,
Next:<a rel=next href="#SAVING%20FILES">SAVING FILES</a>,
Previous:<a rel=previous href="#LOADING%20FILES">LOADING FILES</a>,
Up:<a rel=up href="#LOADING%20AND%20SAVING%20FILES">LOADING AND SAVING FILES</a>
<br>

<h2>LOADING THE BACKUP</h2>

<p>There is one special XML file on disk at all times.  After every
editing operation Cinelerra saves the current project to a backup in
<em>$HOME/.bcast/backup.xml</em>.  In the event of a crash go to
<em>file-&gt;load backup</em> to load the backup.  It is important after a
crash to reboot Cinelerra without performing any editing operations. 
Loading the backup should be the first operation or you'll overwrite
the backup.

<p><hr>
Node:<a name="SAVING%20FILES">SAVING FILES</a>,
Next:<a rel=next href="#RENDERING%20FILES">RENDERING FILES</a>,
Previous:<a rel=previous href="#LOADING%20THE%20BACKUP">LOADING THE BACKUP</a>,
Up:<a rel=up href="#LOADING%20AND%20SAVING%20FILES">LOADING AND SAVING FILES</a>
<br>

<h2>SAVING FILES</h2>

<p>When Cinelerra saves a file it saves an edit decision list of the
current project but doesn't save any media.  Go to <em>File-&gt;save
as...</em>.  Select a file to overwrite or enter a new file.  Cinelerra
automatically concatenates <em>.xml</em> to the filename if no
<em>.xml</em> extension is given.

<p>The saved file contains all the project settings and locations of every
edit but instead of media it contains pointers to the original media
files on disk.

<p>For each media file the XML file stores either an absolute path or just
the relative path.  If the media is in the same directory as the XML
file a relative path is saved.  If it's in a different directory an
absolute path is saved.

<p>In order to move XML files around without breaking the media linkages
you either need to keep the media in the same directory as XML file
forever or save the XML file in a different directory than the media
and not move the media ever again.

<p>If you want to create an audio playlist and burn it on CD-ROM, save the
XML file in the same directory as the audio files and burn the entire
directory.  This keeps the media paths relative.

<p>XML files are useful for saving the current state before going to sleep
and saving audio playlists but they're limited in that they're specific
to Cinelerra.  You can't play XML files in a dedicated movie player. 
Realtime effects in an XML file have to be resynthesized every time you
play it back.  The XML file also requires you to maintain copies of all
the source assets on hard drives, which can take up space and cost a
lot of electricity to spin.  For a more persistent storage of the
output there's rendering.

<p><hr>
Node:<a name="RENDERING%20FILES">RENDERING FILES</a>,
Next:<a rel=next href="#THE%20RENDER%20FARM">THE RENDER FARM</a>,
Previous:<a rel=previous href="#SAVING%20FILES">SAVING FILES</a>,
Up:<a rel=up href="#LOADING%20AND%20SAVING%20FILES">LOADING AND SAVING FILES</a>
<br>

<h2>RENDERING FILES</h2>

<p>Rendering takes a section of the timeline, performs all the editing,
effects and compositing, and stores it in a pure movie file.  You can
then delete all the source assets, play the rendered file in a movie
player, or bring it back into Cinelerra for more editing.  It's very
difficult to retouch any editing decisions in the pure movie file,
however, so keep the original assets and XML file around several days
after you render it.

<p>To begin a render operation you need to define a region of the timeline
to render.  The navigation section describes methods of defining
regions.  See <a href="#NAVIGATING%20THE%20PROJECT">NAVIGATING THE PROJECT</a>.  When a region is highlighted
or in/out points are set, the affected region is rendered.  When no
region is highlighted, everything after the insertion point is
rendered.

<p>Go to <em>File-&gt;render</em> to bring up the render dialog.  Select the
magnifying glass to bring up a file selection dialog.  This determines
the filename to write the rendered file to.

<p>In the render dialog select a format from the <em>File Format</em> menu. 
The format of the file determines whether you can render audio or video
or both.  Select <em>Render audio tracks</em> to generate audio tracks
and <em>Render video tracks</em> to generate video tracks.  Select the
wrench next to each toggle to set compression parameters.  If the file
format can't store audio or video the compression parameters will be
blank.  If <em>Render audio tracks</em> or <em>Render video tracks</em> is
selected and the file format doesn't support it, trying to render will
pop up an error.

<p>The <em>Create new file at each label</em> option causes a new file to be
created when every label in the timeline is encountered.  This is
useful for dividing long audio recordings into individual tracks.  When
using the renderfarm, <em>Create new file at each label</em> causes one
renderfarm job to be created at every label instead of using the
internal load balancing algorithm to space jobs.

<p>When <em>Create new file at each label</em> is selected, a new filename
is created for every output file.  If the filename given in the render
dialog has a 2 digit number in it, the 2 digit number is overwritten
with a different incremental number for every output file.  If no 2
digit number is given, Cinelerra automatically concatenates a number to
the end of the given filename for every output file.

<p>In the filename <em>/hmov/track01.wav</em> the <em>01</em> would be
overwritten for every output file.  The filename
<em>/hmov/track.wav</em>; however, would become <em>/hmov/track.wav001</em>
and so on and so forth.  Filename regeneration is only used when either
renderfarm mode is active or creating new files for every label is
active.

<p>Finally the render dialog lets you select an insertion mode.  The
insertion modes are the same as with loading files.  In this case if
you select <em>insert nothing</em> the file will be written out to disk
without changing the current project.  For other insertion strategies
be sure to prepare the timeline to have the output inserted at the
right position before the rendering operation is finished. 
See <a href="#EDITING">EDITING</a>.  Editing describes how to cause output to be inserted
at the right position.

<p>It should be noted that even if you only have audio or only have video
rendered, a <em>paste</em> insertion strategy will behave like a normal
paste operation, erasing any selected region of the timeline and
pasting just the data that was rendered.  If you render only audio and
have some video tracks armed, the video tracks will get truncated while
the audio output is pasted into the audio tracks.

<p><hr>
Node:<a name="THE%20RENDER%20FARM">THE RENDER FARM</a>,
Previous:<a rel=previous href="#RENDERING%20FILES">RENDERING FILES</a>,
Up:<a rel=up href="#LOADING%20AND%20SAVING%20FILES">LOADING AND SAVING FILES</a>
<br>

<h2>THE RENDER FARM</h2>

<p>When bicubic interpolation and HDTV was first done on Cinelerra, the
time needed to produce the simplest output became unbearable even on
the fastest dual 1.7Ghz Xeon of the time.  Renderfarm support even in
the simplest form brings HDTV times back in line with SD while making
SD faster than realtime.

<p>While the renderfarm interface isn't spectacular, it's simple enough to
use inside an editing suite with less than a dozen nodes without going
through the same amount of hassle you would with a several hundred node
farm.  Renderfarm is invoked transparently for all file-&gt;render
operations when it is enabled in the preferences.

<p>It should be noted that <em>Create new file at each label</em> causes a
new renderfarm job to be created at each label instead of the default
load balancing.  If this option is selected when no labels exist, only
one job will be created.

<p>A Cinelerra renderfarm is organized into a master node and any number
of slave nodes.  The master node is the computer which is running the
GUI.  The slave nodes are anywhere else on the network and are run from
the command line.

<p>Cinelerra divides the selected region of the timeline into a certain
number of jobs which are then dispatched to the different nodes
depending on the load balance.  The nodes process the jobs and write
their output to individual files on the filesystem.  The output files
are not concatenated.  It's important for all the nodes and the master
node to use the same filesystem for assets, mounted over the network.

<p>Since most of the time you'll want to bring in the rendered output and
fine tune it on the timeline, the jobs are left in individual files. 
You can load these using <em>concatenate mode</em> and render them again
with renderfarm disabled.  If the track and output dimensions equal the
asset dimensions, Cinelerra will do a direct copy of all the jobs into
a single file.  Note that direct copying doesn't work for MPEG Video. 
MPEG has the distinction that you can concatenate the subfiles with the
UNIX cat utility.

<p>Configuration of the renderfarm is described in the configuration
chapter See <a href="#RENDERFARM">RENDERFARM</a>.  The slave nodes traditionally read and
write data to a common filesystem over a network, thus they don't need
hard drives.

<p>Ideally all the nodes on the renderfarm have similar CPU performance. 
Cinelerra load balances on a first come first serve basis.  If the last
segment is dispatched to the slowest node, all the fastest nodes may
end up waiting for the slowest node to finish while they themselves
could have rendered it faster.

<p><hr>
Node:<a name="NAVIGATING%20THE%20PROJECT">NAVIGATING THE PROJECT</a>,
Next:<a rel=next href="#EDITING">EDITING</a>,
Previous:<a rel=previous href="#LOADING%20AND%20SAVING%20FILES">LOADING AND SAVING FILES</a>,
Up:<a rel=up href="#Top">Top</a>
<br>

<h1>NAVIGATING THE PROJECT</h1>

<p>The thing you want to do most of the time is get to a certain time and
place in the media.  Internally the media is organized into tracks. 
Each track extends across time.  Navigation involves both getting to a
track and getting to a certain time in the track.

<ul>
<li><a href="#NAVIGATING%20THE%20PROGRAM%20WINDOW">NAVIGATING THE PROGRAM WINDOW</a>: 
<li><a href="#NAVIGATING%20THE%20VIEWER%20AND%20COMPOSITOR">NAVIGATING THE VIEWER AND COMPOSITOR</a>: 
<li><a href="#NAVIGATING%20THE%20RESOURCES">NAVIGATING THE RESOURCES</a>: 
<li><a href="#USING%20THE%20TRANSPORT%20CONTROLS">USING THE TRANSPORT CONTROLS</a>: 
</ul>

<p><hr>
Node:<a name="NAVIGATING%20THE%20PROGRAM%20WINDOW">NAVIGATING THE PROGRAM WINDOW</a>,
Next:<a rel=next href="#NAVIGATING%20THE%20VIEWER%20AND%20COMPOSITOR">NAVIGATING THE VIEWER AND COMPOSITOR</a>,
Up:<a rel=up href="#NAVIGATING%20THE%20PROJECT">NAVIGATING THE PROJECT</a>
<br>

<h2>NAVIGATING THE PROGRAM WINDOW</h2>

<p>The program window contains many features for navigation and displays
the timeline as it is structured in memory: tracks stacked vertically
and extending across time.  The horizontal scroll bar allows you to
scan across time.  The vertical scroll bar allows you to scan across
tracks.

<p>Below the timeline you'll find the zoom panel.  The zoom panel contains
values for <em>sample zoom</em>, <em>amplitude</em>, and <em>track
zoom</em>.  These values in addition to the scrollbars are all that's
needed to position the timeline.

<br><p>
<img src="zoompanel.png" alt="zoompanel.png">,

<p>Changing the <em>sample zoom</em> causes the amount of time visible to
change.  <em>If your mouse has a wheel and it works in X11 go over
the tumblers and use the wheel to zoom in and out.</em>

<p>The <em>amplitude</em> only affects audio.  It determines how big the
waveform is if the waveform is drawn.

<p>The <em>track zoom</em> affects all tracks.  It determines the height of
each track.  If you change the track zoom the amplitude zoom
compensates so  audio waveforms look proportional.

<p>In addition to the graphical tools, you'll probably more often use the
keyboard to navigate.  Use <em>PAGE UP</em> and <em>PAGE DOWN</em> to
scroll up and down the tracks.

<p>Use the <em>LEFT</em> and <em>RIGHT</em> arrows to move across time. 
You'll often need to scroll beyond the end of the timeline but
scrollbars won't let you do it.  Instead use the <em>RIGHT</em> arrow to
scroll past the end of timeline.

<p>Use the <em>UP</em> and <em>DOWN</em> arrows to change the sample zoom by a
power of 2.

<p><em>CTRL-UP</em> and <em>CTRL-DOWN</em> cause the amplitude zoom to change.

<p><em>CTRL-PGUP</em> and <em>CTRL-PGDOWN</em> cause the track zoom to change.

<ul>
<li><a href="#THE%20INSERTION%20POINT">THE INSERTION POINT</a>: 
<li><a href="#THE%20IN%2fOUT%20POINTS">THE IN/OUT POINTS</a>: 
<li><a href="#USING%20LABELS%20IN%20THE%20PROGRAM%20WINDOW">USING LABELS IN THE PROGRAM WINDOW</a>: 
</ul>

<p><hr>
Node:<a name="THE%20INSERTION%20POINT">THE INSERTION POINT</a>,
Next:<a rel=next href="#THE%20IN%2fOUT%20POINTS">THE IN/OUT POINTS</a>,
Up:<a rel=up href="#NAVIGATING%20THE%20PROGRAM%20WINDOW">NAVIGATING THE PROGRAM WINDOW</a>
<br>

<h3>THE INSERTION POINT</h3>

<p>By default you'll see a flashing insertion point in the program window
the first time you boot it up.  This is where new media is pasted onto
the timeline.  It's also the starting point of all playback
operations.  When rendering it defines the region of the timeline to be
rendered.

<p>The insertion point is normally moved by clicking inside the timebar. 
Any region of the timebar not obscured by labels and in/out points is a
hotspot for repositioning the insertion point.

<br><p>
<img src="main_timebar.png" alt="main_timebar.png">,
<em>The main timebar</em>

<p>The insertion point also can be moved by clicking in the timeline
itself, but not always.  The insertion point has two modes of
operation:

<ul>
<li>drag and drop mode

<li>cut and paste mode

</ul>

<p>The mode of operation is determined by selecting the arrow or the
i-beam in the buttonbar.

<br><p>
<img src="editing_mode.png" alt="editing_mode.png">,
<em>The editing mode buttons</em>

<p>If the arrow is highlighted it enables <em>drag and drop</em> mode.  In
drag and drop mode, clicking in the timeline doesn't reposition the
insertion point.  Instead it selects an entire edit.  Dragging in the
timeline repositions the edit, snapping it to other edit boundaries. 
This is normally useful for reordering audio playlists and moving
effects around.

<p>If the i-beam is highlighted it enables <em>cut and paste mode</em>.  In
cut and paste mode clicking in the timeline repositions the insertion
point.  Dragging in the timeline highlights a region.  The highlighted
region becomes the playback range during the next playback operation,
the rendered range during the next render operation, and the region
affected by cut and paste operations.

<p><em>Shift-clicking</em> in the timeline extends the highlighted region.

<p><em>Double-clicking</em> in the timeline selects the entire edit the
cursor is over.

<p>It should be noted that when moving the insertion point and selecting
regions, the positions are either aligned to frames or aligned to
samples.  When editing video you'll want to align to frames.  When
editing audio you'll want to align to samples.  This is set in
<em>settings-&gt;align cursor on frames</em>.

<p>If the highlighted region is the region affected by cut and paste
operations, how do I cut and paste in <em>drag and drop</em> mode?  In
this case you need to set <em>in/out points</em> to define an affected region.

<p><hr>
Node:<a name="THE%20IN%2fOUT%20POINTS">THE IN/OUT POINTS</a>,
Next:<a rel=next href="#USING%20LABELS%20IN%20THE%20PROGRAM%20WINDOW">USING LABELS IN THE PROGRAM WINDOW</a>,
Previous:<a rel=previous href="#THE%20INSERTION%20POINT">THE INSERTION POINT</a>,
Up:<a rel=up href="#NAVIGATING%20THE%20PROGRAM%20WINDOW">NAVIGATING THE PROGRAM WINDOW</a>
<br>

<h3>THE IN/OUT POINTS</h3>

<p>In both editing modes you can set in/out points.  The in/out points
define the affected region.  In drag and drop mode they are the only
way to define an affected region.  In both cut and paste mode and drag
and drop mode they override the highlighted area.  If a highlighted
area and in/out points are set, the highlighted area affects playback
while the in/out points affect editing operations.  To avoid confusion
it's best to use either highlighting or in/out points but not both
simultaneously.

<p>To set in/out points go to the timebar and position the insertion point
somewhere.  Hit the <img src="in_point_button.png" alt="in_point_button.png"> <em>in point button</em>.  Go
to a position after the in point and hit the <img src="out_point_button.png" alt="out_point_button.png">
<em>out point button</em>.

<br><p>
<img src="inout_points.png" alt="inout_points.png"> <em>Timebar with in/out points set</em>.

<p>Select either the in point or the out point and the insertion point
jumps to that location.  After selecting an in point, if you hit the
<em>in point button</em> the in point will be deleted.  After selecting
an out point, if you hit the <em>out point button</em> the out point will
be deleted.

<p>If you select a region somewhere else while in/out points already
exist, the existing points will be repositioned when you hit the in/out
buttons.

<p><em>Shift-clicking</em> on an in/out point extends the highlighted region
to that point.

<p>Instead of using the button bar you can use the <em>[</em> and <em>]</em>
keys to toggle in/out points.

<p>The insertion point and the in/out points allow you to define an
affected region but they don't let you jump to exact points on the
timeline very easily.  For this purpose there are labels.

<p><hr>
Node:<a name="USING%20LABELS%20IN%20THE%20PROGRAM%20WINDOW">USING LABELS IN THE PROGRAM WINDOW</a>,
Previous:<a rel=previous href="#THE%20IN%2fOUT%20POINTS">THE IN/OUT POINTS</a>,
Up:<a rel=up href="#NAVIGATING%20THE%20PROGRAM%20WINDOW">NAVIGATING THE PROGRAM WINDOW</a>
<br>

<h3>USING LABELS IN THE PROGRAM WINDOW</h3>

<p>Labels are an easy way to set exact locations on the timeline you want
to jump to.  When you position the insertion point somewhere and hit
the <img src="label_button.png" alt="label_button.png"> <em>label button</em> a new label appears on the
timeline.

<br><p>
<img src="timebar_label.png" alt="timebar_label.png"> <em>Timebar with a label on it</em>

<p>No matter what the zoom settings are, clicking on the label positions
the insertion point exactly where you set it.  Hitting the label button
again when a label is selected deletes it.

<p><em>Shift-clicking</em> on a label extends the highlighted region.

<p><em>Double-clicking</em> between two labels highlights the region between
the labels.

<p>Hitting the <em>l</em> key has the same effect as the label button.

<p>If you hit the label button when a region is highlighted, two labels
are toggled at each end of the highlighted region.  If one end already
has a label, then the existing label is deleted and a label is created
at the opposite end.

<p>Labels can reposition the insertion point when they are selected but
they can also be traversed with the <img src="label_traversal.png" alt="label_traversal.png"> <em>label
traversal</em> buttons.  When a label is out of view, the label traversal
buttons reposition the timeline so the label is visible.  There are
keyboard shortcuts for label traversal, too.

<p><em>CTRL-LEFT</em> repositions the insertion point on the previous label.

<p><em>CTRL-RIGHT</em> repositions the insertion point on the next label.

<p>With label traversal you can quickly seek back and forth on the
timeline but you can also select regions.

<p><em>SHIFT-CTRL-LEFT</em> extends the highlighted region to the previous
label.

<p><em>SHIFT-CTRL-RIGHT</em> extends the highlighted region to the next label.

<p>Manually hitting the label button or <em>l</em> key over and over again
to delete a series of labels can get tedious.  For deleting a set of
labels, first highlight a region and second use the <em>Edit-&gt;Clear
labels</em> function.  If in/out points exist, the labels between the
in/out points are cleared and the highlighted region ignored.

<p><hr>
Node:<a name="NAVIGATING%20THE%20VIEWER%20AND%20COMPOSITOR">NAVIGATING THE VIEWER AND COMPOSITOR</a>,
Next:<a rel=next href="#NAVIGATING%20THE%20RESOURCES">NAVIGATING THE RESOURCES</a>,
Previous:<a rel=previous href="#NAVIGATING%20THE%20PROGRAM%20WINDOW">NAVIGATING THE PROGRAM WINDOW</a>,
Up:<a rel=up href="#NAVIGATING%20THE%20PROJECT">NAVIGATING THE PROJECT</a>
<br>

<h2>NAVIGATING THE VIEWER AND COMPOSITOR</h2>

<p>The navigation features of the Viewer and Compositor behave very
similarly.  Each has a timebar and slider below the video output.  The
timebar and slider are critical for navigation.

<br><p>
<img src="timebarslider.png" alt="timebarslider.png">,

<p>The timebar represents the entire time covered by the program.  When
you define labels and in/out points it defines those, too.  Finally the
timebar defines a region known as the <em>preview region</em>.

<p>The <em>preview region</em> is the region of the timeline which the
slider effects.  The slider only covers the time covered by the preview
region.  By using a preview region inside the entire program and using
the slider inside the preview region you can quickly and precisely seek
in the compositor and viewer.

<p>When you replace the current project with a file the preview region
automatically resizes to cover the entire file.  When you append data
or change the size of the current project, the preview region stays the
same size and shrinks.  Therefore, you need to resize the preview
region.

<p>Load a file and then slide around it using the compositor slider.  The
insertion point in the main window follows the compositor.  Move the
pointer over the compositor's timebar until it turns into a left resize
pointer.  The click and drag right.  The preview region should have
changed and the slider resized proportionally.

<p>Go to the right of the timebar until a right resize pointer appears. 
Drag left so the preview region shrinks.

<p>Go to the center of the preview region in the timebar and drag it
around to convince yourself if can be moved.

<br><p>
<img src="previewregion.png" alt="previewregion.png">,

<p><em>Preview region in compositor</em>

<p>If you go to the slider and slide it around with the preview region
shrunk, you'll see the slider only affects the preview region.  The
timebar and slider in the viewer window work exactly the same.

<p>Labels and in/out points are fully supported in the viewer and
compositor.  The only difference between the viewer and compositor is
the compositor reflects the state of the program while the viewer
reflects the state of a clip but not the program.

<p>When you hit the <em>label button</em> in the compositor, the label
appears both in the compositor timebar and the program timebar.

<p>When you select a label or in/out point in the compositor, the program
window jumps to that position.

<br><p>
<img src="viewer_labels.png" alt="viewer_labels.png"> <em>Labels and in/out points in the viewer</em>.

<p>In the viewer and compositor, labels and in/out points are displayed in
the timebar.  Instead of displaying just a region of the program, the
timebar displays the entire program here.

<p>Like the Program window, the Compositor has a zoom capability.  First,
the pulldown menu on the bottom of the compositor window has a number
of zoom options.  When set to <em>Auto</em> the video is zoomed to match
the compositor window size as closely as possible.  When set to any
other percentage, the video is zoomed a power of 2 and scrollbars can
be used to scroll around the output.  When the video is zoomed bigger
than the window size, not only do scrollbars scan around it but
<em>middle mouse button</em> dragging in the video output scans around
it.  This is exactly when The Gimp does.

<p>Furthermore, the zoom <img src="magnify.png" alt="magnify.png"> toggle causes the Compositor
window to enter zoom mode.  In zoom mode, clicking in the video output
zooms in while <em>ctrl-clicking</em> in the video output zooms out.  If
you have a wheel mouse, rotating the wheel zooms in or out too.

<p>Zooming in or out with the zoom tool does not change the rendered
output, mind you.  It's merely for scrutinizing video or fitting it in
the desktop.

<p><hr>
Node:<a name="NAVIGATING%20THE%20RESOURCES">NAVIGATING THE RESOURCES</a>,
Next:<a rel=next href="#USING%20THE%20TRANSPORT%20CONTROLS">USING THE TRANSPORT CONTROLS</a>,
Previous:<a rel=previous href="#NAVIGATING%20THE%20VIEWER%20AND%20COMPOSITOR">NAVIGATING THE VIEWER AND COMPOSITOR</a>,
Up:<a rel=up href="#NAVIGATING%20THE%20PROJECT">NAVIGATING THE PROJECT</a>
<br>

<h2>NAVIGATING THE RESOURCES</h2>

<p>The resource window is divided into two areas.  One area lists folders
and another area lists folder contents.  Going into the folder list and
clicking on a folder updates the contents area with the contents of
that folder.

<p>The folder and contents can be displayed as icons or text.

<p><em>Right clicking</em> in the folder or contents area brings up a menu
containing formatting options.  Select <em>Display text</em> to display a
text listing.  Select <em>Sort items</em> to sort the contents of the
folder alphabetically.

<p><hr>
Node:<a name="USING%20THE%20TRANSPORT%20CONTROLS">USING THE TRANSPORT CONTROLS</a>,
Previous:<a rel=previous href="#NAVIGATING%20THE%20RESOURCES">NAVIGATING THE RESOURCES</a>,
Up:<a rel=up href="#NAVIGATING%20THE%20PROJECT">NAVIGATING THE PROJECT</a>
<br>

<h2>USING THE TRANSPORT CONTROLS</h2>

<p>Transport controls are just as useful in navigation as they are in
playing back footage, hence they are described here.  Each of the
Viewer, Compositor, and Program windows has a transport panel.

<br><p>
<img src="transport_panel.png" alt="transport_panel.png"> <em>The transport panel</em>.

<p>The transport panel is controlled by the keyboard as well as the
graphical interface.  For each of the operations it performs, the
starting position is the position of the insertion point or slider. 
The ending position is either the end or start of the timeline or the
end or start of the selected region if there is one.

<p>The orientation of the end or start depends on the direction of
playback.  If it's forward the end position is the end of the selected
region.  If it's backward the end position is the start of the selected
region.

<p>The insertion point moves to track playback.  When playback stops it
leaves the insertion point where it stopped.  Thus, by playing back you
change the position of the insertion point.

<p>The keyboard interface is usually the fastest and has more speeds.  The
transport keys are arranged in a <em>T</em> on the number pad.

<ul>

<li><em>+</em> Fast reverse
<li><em>6</em> Normal reverse
<li><em>5</em> Slow reverse
<li><em>4</em> Frame reverse
<li><em>1</em> Frame forward
<li><em>2</em> Slow forward
<li><em>3</em> Normal forward
<li><em>Enter</em> Fast forward
<li><em>0</em> Stop
<li><em>Spacebar</em> Normal forward
</ul>

<p>Hitting any key on the keyboard twice pauses it.

<p>When using frame advance functions the behavior may seem odd.  If you
frame advance forward and then frame advance backward, the displayed
frame doesn't change.  This is because the playback position isn't the
frame but the time between two frames.  The rendered frame is the area
that the playback position crosses.  When you increment the time
between two frames by one and decrement it by one, you cross the same
frame both times and so the same frame is displayed.

<p><hr>
Node:<a name="EDITING">EDITING</a>,
Next:<a rel=next href="#USING%20EFFECTS">USING EFFECTS</a>,
Previous:<a rel=previous href="#NAVIGATING%20THE%20PROJECT">NAVIGATING THE PROJECT</a>,
Up:<a rel=up href="#Top">Top</a>
<br>

<h1>EDITING</h1>

<p>Editing comprises both the time domain and the track domain.  Since the
timeline consists of a stack of tracks, you need to worry about how to
sort and create tracks in addition to what time certain media appears
on a track.

<p>In the time domain, Cinelerra offers many ways to approach the editing
process.  The three main methods are two screen editing, drag and drop
editing, and cut and paste editing.

<p>There are several concepts Cinelerra uses when editing which apply to
all the methods.  The timeline is where all editing decisions are
represented.  Every track on the timeline has a set of attributes on
the left, the most important of which is the <em>arm track</em>
attribute.

<br><p>
<img src="track_attributes.png" alt="track_attributes.png"><em>Track attributes</em>

<p>Only the <em>armed tracks</em> are affected by editing operations.  Make
sure you have enough armed destination tracks when you paste or splice
material or some tracks in the material will get left out.

<p>In addition to editing operations, the armed tracks in combination with
the active region determine where material is inserted when loading
files.  If the files are loaded with one of the insertion strategies
which doesn't delete the existing project, the armed tracks will be
used as destination tracks.

<p>The active region is the range of time in the edit decision on the
timeline.  The active region is determined first by the presence of
in/out points in the timeline.  If those don't exist the highlighted
region is used.  If no highlighted region exists the insertion point is
used as the active region and the active length is 0.

<p>Finally, editing decisions never affect source material.  Editing only affects
pointers to source material, so if you want to have a media file at the
end of your editing session which represents the editing decisions, you
need to <em>render</em> it. See <a href="#RENDERING%20FILES">RENDERING FILES</a>.

<ul>
<li><a href="#MANIPULATING%20TRACKS">MANIPULATING TRACKS</a>: 
<li><a href="#TWO%20SCREEN%20EDITING">TWO SCREEN EDITING</a>: 
<li><a href="#DRAG%20AND%20DROP%20EDITING">DRAG AND DROP EDITING</a>: 
<li><a href="#CUT%20AND%20PASTE%20EDITING">CUT AND PASTE EDITING</a>: 
<li><a href="#TRIMMING">TRIMMING</a>: 
</ul>

<p><hr>
Node:<a name="MANIPULATING%20TRACKS">MANIPULATING TRACKS</a>,
Next:<a rel=next href="#TWO%20SCREEN%20EDITING">TWO SCREEN EDITING</a>,
Up:<a rel=up href="#EDITING">EDITING</a>
<br>

<h2>MANIPULATING TRACKS</h2>

<p>Tracks in Cinelerra either contain audio or video.  There is no special
designation for tracks other than the type of media they contain.  When
you create a new project, it contains a certain mumber of default
tracks.  You can still add or delete tracks from a number of menus. 
The <em>Tracks</em> menu contains a number of options for dealing with
multiple tracks simultaneously.  Each track itself has a popup menu
which affects one track.

<p>Bring up the popup menu by moving over a track and right clicking.  The
popup menu affects the track whether it's armed or not.

<p><em>Move up</em> and <em>move down</em> moves the one track up or down in
the stack.  <em>Delete track</em> deletes the track.

<p>Operations in the <em>Tracks</em> menu affect only tracks which are
armed.

<p><em>Move tracks up</em> and <em>Move tracks down</em> shift all the armed
tracks up or down the stack.

<p><em>Delete tracks</em> deletes the armed tracks.

<p><em>Delete last track</em> deletes the last track, whether it's armed or
not.  Holding down the <em>d</em> key quickly deletes all the tracks.

<p><em>Concatenate tracks</em> is more complicated.  It takes every
<em>playable</em> track and concatenates it to the end of the first
<em>armed tracks</em>.  If there are two armed tracks followed by two
playable tracks, the concatenate operation puts the two playable tracks
after the two armed tracks.  If there are three playable tracks
instead, two tracks are put after the armed tracks and a third track is
put on the end of the first armed track.  The destination track wraps
around until all the playable tracks are concatenated.

<p>Finally, you'll want to create new tracks.  The <em>Audio</em> and
<em>Video</em> menus each contain an option to add a track of their
specific type.  In the case of audio, the new track is put on the
bottom of the timeline and the output channel of the audio track is
incremented by one.  In the case of video, the new track is put on the
top of the timeline.  This way, video has a natural compositing order. 
New video tracks are overlayed on top of old tracks.

<p><hr>
Node:<a name="TWO%20SCREEN%20EDITING">TWO SCREEN EDITING</a>,
Next:<a rel=next href="#DRAG%20AND%20DROP%20EDITING">DRAG AND DROP EDITING</a>,
Previous:<a rel=previous href="#MANIPULATING%20TRACKS">MANIPULATING TRACKS</a>,
Up:<a rel=up href="#EDITING">EDITING</a>
<br>

<h2>TWO SCREEN EDITING</h2>

<p>This is the fastest way to construct a program out of movie files.  The
idea consists of viewing a movie file in one window and viewing the
program in another window.  Sections of the movie file are defined in
one window and transferred to the end of the program in the other
window.

<p>The way to begin a two screen editing session is to load some
resources.  In <em>file-&gt;load</em> load some movies with the insertion
mode <em>create new resources</em>.  You want the timeline to stay
unchanged while new resources are brought in.  Go to the Resource
Window and select the <em>media</em> folder.  The newly loaded resources
should appear.  Drag a resource from the media side of the window over
the Viewer window.

<p>There should be enough armed tracks on the timeline to put the sections
of source material that you want.  If there aren't, create new tracks
or arm more tracks.

<p>In the viewer window seek to the starting point of a clip you want to
use.  Use either the <em>slider</em> or the <em>transport controls</em>. 
Use the <em>preview region</em> to narrow down the search.  Set the
starting point with the <img src="in_point_button.png" alt="in_point_button.png"> <em>in point button</em>.

<p>Seek to the ending point of the clip you want to use.  Set the ending
point with the <img src="out_point_button.png" alt="out_point_button.png"> <em>out point button</em>.  The
two points should now appear on the timebar and define a clip.

<p>There are several things you can do with the clip now.

<ul>

<li>
Splice <img src="splice_button.png" alt="splice_button.png"> inserts the clip in the timeline, pushing
everything back.  If an <em>in point</em> or <em>out point</em> exists on
the timeline it's inserted there, otherwise it's inserted after the
insertion point.  After that, the insertion point moves to the end of
the clip.  If there is no in/out point, the insertion point will be
used as the next splice location.  This way you can continuously build
up the program by splicing.

<li>
Overwrite <img src="overwrite_button.png" alt="overwrite_button.png"> overwrites the region of the
timeline with the clip.  If an <em>in point</em> or <em>out point</em>
exists on the timeline it's overwritten there, otherwise it's
overwritten after the insertion point.  If a region is highlighted or
both in and out points exist the difference between the active region
and the clip length is deleted.

<li>
Create a clip <img src="toclip_button.png" alt="toclip_button.png"> generates a new clip for the
resource window containing the affected region but doesn't change the
timeline.  Every clip has a title and a description.  These are
optional.

<li>
Copy behaves the same as in cut and paste editing.

</ul>

<p>Two screen editing can be done purely by keybard shortcuts.  When you
move the pointer over any button a tooltip should appear, showing what
key is bound to that button.  In the Viewer window, the number pad keys
control the transport and the <em>[ ] v</em> keys perform in/out points
and splicing.

<p><hr>
Node:<a name="DRAG%20AND%20DROP%20EDITING">DRAG AND DROP EDITING</a>,
Next:<a rel=next href="#CUT%20AND%20PASTE%20EDITING">CUT AND PASTE EDITING</a>,
Previous:<a rel=previous href="#TWO%20SCREEN%20EDITING">TWO SCREEN EDITING</a>,
Up:<a rel=up href="#EDITING">EDITING</a>
<br>

<h2>DRAG AND DROP EDITING</h2>

<p>The answer is yes, you can you create a bunch of clips and drag them on
the timeline.  You can also drag edits around the timeline.

<p>Load some files using <em>file-&gt;load</em>.  Set the insertion mode to
<em>Create new resources</em>.  This loads the files into the Resource
Window.  Create some audio and video tracks on the timeline using the
video and audio menus.

<p>Open the <em>Media</em> folder in the resource window.  Drag a media file
from the resource window to the timeline.  If the media has video, drag
it onto a video track.  If the media is pure audio, drag it onto an
audio track.

<p>Cinelerra fills out the audio and video tracks below the dragging
cursor with data from the file.  This affects what tracks you should
create initially and which track to drag the media onto.  If the media
has one video track and two audio tracks, you'll need one video track
and two audio tracks on the timeline and the media should be dragged
over the first video track.  If the media has audio only you'll need
one audio track on the timeline for every audio track in the media and
the media should be dragged over the first audio track.

<p>When dragging, the media snaps to the start of track if the track is
empty.  If there are edits on the track, the media snaps to the nearest
edit boundary.

<p>You can also drag multiple files from the resource window.  Either draw
a box around the files, use SHIFT, or use CTRL when selecting files. 
When you drop the files in the timeline, they are concatenated.  The
behavior of SHIFT and CTRL changes depending on if the resources are in
text or icons.

<p>To display the resources as text or icons, right click inside the media
list.  Select either <em>display icons</em> or <em>display text</em> to
change the list format.

<p>When displaying text in the resource window <em>SHIFT-clicking</em> on
media files extends the number of highlighted selections. 
<em>CTRL-clicking</em> on media files in text mode selects additional
files one at a time.

<p>When displaying icons in the resource window <em>SHIFT-clicking</em> or
<em>CTRL-clicking</em> selects media files one at a time.

<p>In addition to dragging media files, if you create clips and open the
<em>clip</em> folder you can drag clips on the timeline.

<p>In the timeline there is further dragging functionality.  To enable the
dragging functionality of the timeline, select the arrow toggle
<img src="arrow.png" alt="arrow.png">.  Move over an edit and drag it.  If more than one
track is armed, Cinelerra will drag any edits which start on the same
position as the edit the cursur is currently over.  During a dragging
operation the edit snaps to the nearest boundary.

<p>Dragging edits around the timeline allows you to sort music playlists,
sort movie scenes, and give better NAB demos but not much else.

<p><hr>
Node:<a name="CUT%20AND%20PASTE%20EDITING">CUT AND PASTE EDITING</a>,
Next:<a rel=next href="#TRIMMING">TRIMMING</a>,
Previous:<a rel=previous href="#DRAG%20AND%20DROP%20EDITING">DRAG AND DROP EDITING</a>,
Up:<a rel=up href="#EDITING">EDITING</a>
<br>

<h2>CUT AND PASTE EDITING</h2>

<p>This is the traditional method of editing in audio editors.  In the
case of Cinelerra, you either need to start a second copy of Cinelerra
and copy from one copy to the other, copy from different tracks in the
same copy, or load a media file into the Viewer and copy from there.

<p>Load some files onto the timeline.  To perform cut and paste editing
select the <img src="ibeam.png" alt="ibeam.png"> i-beam toggle.  Select a region of the
timeline and select the <img src="cut.png" alt="cut.png"> cut button to cut it.  Move the
insertion point to another point in the timeline and select the
<img src="paste.png" alt="paste.png"> paste button.  Assuming no in/out points are defined on
the timeline this performs a cut and paste operation.

<p>If in/out points are defined, the insertion point and highlighted
region are overridden by the in/out points for clipboard operations. 
Thus, with in/out points you can perform cut and paste in drag and drop
mode as well as cut and paste mode.

<p>When editing audio, it is customary to cut from one part of a waveform
into the same part of another waveform.  The start and stop points of
the cut are identical in each waveform and might be offset slightly,
while the wave data is different.  It would be very hard to highlight
one waveform to cut it and highlight the second waveform to paste it
without changing the relative start and stop positions.

<p>One option for simplifying this is to open a second copy of Cinelerra,
cutting and pasting to transport media between the two copies.  This
way two highlighed regions can exist simultanously.

<p>Another option is to set in/out points for the source region of the
source waveform and set labels for the destination region of the
destination waveform.  Perform a cut, clear the in/out points, select
the region between the labels, and perform a paste.

<p>A final operation in cut and paste editing is the <em>edit-&gt;clear</em>
operation.  If a region is highlighted or in/out points exist, the
affected region is cleared by <em>edit-&gt;clear</em>.  But if the insertion
point is over an edit boundary and the edits on each side of the edit
boundary are the same resource, the edits are combined into one edit
comprised by the resource.  The start of this one edit is the start of
the first edit and the end of this one edit is the end of the second
edit.  This either results in the edit expanding or shrinking.

<p><hr>
Node:<a name="TRIMMING">TRIMMING</a>,
Previous:<a rel=previous href="#CUT%20AND%20PASTE%20EDITING">CUT AND PASTE EDITING</a>,
Up:<a rel=up href="#EDITING">EDITING</a>
<br>

<h2>TRIMMING</h2>

<p>With some edits on the timeline it's possible to do trimming.  By
trimming you shrink or grow the edit boundaries by dragging them.  In
either drag and drop mode or cut and paste mode, move the cursor over
an edit boundary until it changes shape.  The cursor will either be an
expand left or an expand right.  If the cursor is an expand left, the
dragging operation affects the beginning of the edit.  If the cursor is
an expand right, the dragging operation affects the end of the edit.

<p>When you click on an edit boundary to start dragging, the mouse button
number determines which dragging behavior is going to be followed.  3
possible behaviors are bound to mouse buttons in the interface
preferences. See <a href="#INTERFACE">INTERFACE</a>.

<p>The effect of each drag operation not only depends on the behavior
button but whether the beginning or end of the edit is being dragged. 
When you release the mouse button, the trimming operation is performed.

<p>In a <em>Drag all following edits</em> operation, the beginning of the
edit either cuts data from the edit if you move it forward or pastes
new data from before the edit if you move it backward.  The end of the
edit pastes data into the edit if you move it forward or cuts data from
the end of the edit if you move it backward.  All the edits thereafter
shift.  Finally, if you drag the end of the edit past the start of the
edit, the edit is deleted.

<p>In a <em>Drag only one edit</em> operation, the behavior is the same when
you drag the beginning or end of an edit.  The only difference is none
of the other edits in the track shift.  Instead, anything adjacent to
the current edit expands or shrinks to fill gaps left by the drag
operation.

<p>In a <em>Drag source only</em> operation, nothing is cut or pasted.  If
you move the beginning or end of the edit forward, the source reference
in the edit shifts forward.  If you move the beginning or end of the
edit backward, the source reference shifts backward.  Where the edit
appears in the timeline remains the same but the source shifts.

<p>For all file formats besides still images, the extent of the trimming
operation is clamped to the source file length.  Attempting to drag the
start of the edit beyond the start of the source clamps it to the
source start.

<p>In all trimming operations, all edits which start on the same position
as the cursor when the drag operation begins are affected.  Unarm
tracks to prevent edits from getting affected.

<p><hr>
Node:<a name="USING%20EFFECTS">USING EFFECTS</a>,
Next:<a rel=next href="#SETTING%20PROJECT%20ATTRIBUTES">SETTING PROJECT ATTRIBUTES</a>,
Previous:<a rel=previous href="#EDITING">EDITING</a>,
Up:<a rel=up href="#Top">Top</a>
<br>

<h1>USING EFFECTS</h1>

<p>It would be sufficient to perform all changes to the timeline using
editing operations, but this isn't very extensible.  Certain timeline
changes should produce a different effect in the output without
involving a unique procedure to apply each change.  This is why we have
effects.

<p>Effects fall into three categories, and each effect in a category is
applied using the same procedure.

<ul>
<li><a href="#REALTIME%20EFFECTS">REALTIME EFFECTS</a>: 
<li><a href="#RENDERED%20EFFECTS">RENDERED EFFECTS</a>: 
<li><a href="#TRANSITIONS">TRANSITIONS</a>: 
</ul>

<p><hr>
Node:<a name="REALTIME%20EFFECTS">REALTIME EFFECTS</a>,
Next:<a rel=next href="#RENDERED%20EFFECTS">RENDERED EFFECTS</a>,
Up:<a rel=up href="#USING%20EFFECTS">USING EFFECTS</a>
<br>

<h2>REALTIME EFFECTS</h2>

<p>These are layered under the track they apply to.  They process the
track when the track is played back, with no permanent storage of the
output except when the project is rendered.

<p>All the realtime effects are listed in the resource window, divided
into two groups: audio effects and video effects.  Audio effects should
be dragged from the resource window onto audio tracks.  Video effects
should be dragged onto video tracks.

<p>If there is data on the destination track, the effect is applied to the
entire track.  If there is no data on the track the effect is deleted. 
Finally, if a region of the track is selected the effect is pasted into
the region, regardless of whether there is data.

<p>Some of the effects don't process data but synthesize data.  In the
case of a synthesis effect, you'll want to select a region of the
track so the dragging operation pastes it without deleting it.

<p>When dragging more than one effect onto a track, you'll see the effects
layering from top to bottom, on the bottom of the track.   When the
track is played back, effects are processed from top to bottom.  The
output of the top effect becomes the input of the bottom effect and so
on and so forth.

<p>In addition to dragging from the resource window, effects may be
applied to a track by a popup menu.  Right click on a track and select
<em>Attach effect</em> from the popup.  The attach effect dialog gives
you more control than pure dragging and dropping.  For one thing, the
attach effect dialog lets you attach two more types of effects: shared
effects and shared tracks.  Select a plugin from the <em>Plugins</em>
column and hit <em>Attach</em> under the plugins column to attach it. 
The effect is the same as if the effect was dragged from the resource
window.

<p>When an effect exists under a track, it most often needs to be
configured.  Go to the effect and right click on it to bring up the
effect popup.  In the effect popup is a <em>show</em> option.  The show
option causes the GUI for the effect to appear under the cursor.  Most
effects have GUI's but some don't.  If the effect doesn't have a GUI,
nothing pops up when the <em>show</em> option is selected.  When you
tweek parameters in the effect GUI, the parameters normally effect the
entire duration of the effect.

<ul>
<li><a href="#REALTIME%20EFFECT%20TYPES">REALTIME EFFECT TYPES</a>: 
<li><a href="#EDITING%20REALTIME%20EFFECTS">EDITING REALTIME EFFECTS</a>: 
</ul>

<p><hr>
Node:<a name="REALTIME%20EFFECT%20TYPES">REALTIME EFFECT TYPES</a>,
Next:<a rel=next href="#EDITING%20REALTIME%20EFFECTS">EDITING REALTIME EFFECTS</a>,
Up:<a rel=up href="#REALTIME%20EFFECTS">REALTIME EFFECTS</a>
<br>

<h3>REALTIME EFFECT TYPES</h3>

<p>The two other effect types supported by the Attach Effect dialog are
recycled effects.  In order to use a recycled effect, three requiremenets
must be met:

<ul>

<li>There must be other effects in the timeline.

<li>
The other effects must be of the same type as the track you're
attaching an effect to.  If the track is an audio track, the effects
must be audio effects.  If the track is a video track, the effects must
be video effects.

<li>
The insertion point or selected region must start inside the other effects.

</ul>

<p>In the case of a shared effect, these conditions must be true.  In the
case of a shared track, there merely must be another track on the
timeline of the same type as the track you're applying an effect to. 
If you right clicked on a video track to attach an effect, there won't
be anything in the <em>shared tracks</em> column if no other video track
exists.  If you right clicked on an audio track there won't be anything
in the shared track column if no other audio track exists.

<p>If shared effects or shared tracks are available, they appear in the
<em>shared effects</em> and <em>shared tracks</em> columns.  The
<em>attach</em> button under each column causes anything highlighted in
the column to be attached under the current track.

<p>Shared effects and shared tracks allow very unique things to be done. 
In the case of a shared effect, the shared effect is treated like a
copy of the original effect except in the shared effect the GUI can't
be brought up.  All configuration of the shared effect is determined by
the GUI of the original effect and only the GUI of the original effect
can be brought up.

<p>When a shared effect is played back, it's processed just like a normal
effect except the configuration is copied from the original effect. 
Some effects detect when they are being shared, like the reverb effects
and the compressor.  These effects determine what tracks are sharing
them and either mix the two tracks together or use one track to stage
some value.  The reverb mixes tracks together to simulate ambience. 
The compressor uses one of the sharing tracks as the trigger.

<p>When an original track has a <em>shared track</em> as one of its effects,
the shared track itself is used as a realtime effect.  This is more
commonly known as <em>bouncing tracks</em> but Cinelerra achieves the
same operation by attaching shared tracks.  The fade and any effects in
the shared track are applied to the original track.  Once the shared
track has processed the data, the original track performs any effects
which come below the shared track and then composites it on the output.

<p>In addition, once the shared track has processed the output of the
original track like a realtime effect, the shared track mixes itself
into the output with it's settings for pan, mode, and projector.  Thus,
two tracks are mixing the same data on the output.  Most of the time
you don't want the shared track to mix the same data as the original
track on the output.  You want it to stop right before the mixing stage
and give the data back to the original track.  Do this by enabling the
<img src="mutepatch_up.png" alt="mutepatch_up.png"> mute toggle next to each track for whom you don't
want to mix on the output.

<p>Suppose you were making video and you did want the shared track to
composite the original track's data on the output a second time.  In
the case of video, the video from the shared track would always appear
under the video from the original track, regardless of whether it was
on top of the original track.  This is because shared tracks are
composited in order of their attachment.  Since it's part of the original
track it has to be composited before the original track is composited.

<p><hr>
Node:<a name="EDITING%20REALTIME%20EFFECTS">EDITING REALTIME EFFECTS</a>,
Previous:<a rel=previous href="#REALTIME%20EFFECT%20TYPES">REALTIME EFFECT TYPES</a>,
Up:<a rel=up href="#REALTIME%20EFFECTS">REALTIME EFFECTS</a>
<br>

<h3>EDITING REALTIME EFFECTS</h3>

<p>Many operations exist for manipulating effects once they are in the
timeline.  Because mixing effects and media is such complex business,
the methods used in editing effects aren't as concise as cutting and
pasting.  Some of the editing happens by dragging in/out points, some
of the editing happens through popup menus, and some of it happens by
dragging effects.

<p>Normally when you edit tracks, the effects follow the editing
decisions.  If you cut from a track, the effect shrinks.  If you drag
edit in/out points, the effect changes length.  This behavior can be
disabled by selecting <em>Settings-&gt;edit effects</em> in the project
window.  This decouples effects from editing operations, but what if
you just want to edit the effects?

<p>Move the timeline cursor over the effect borders until it changes to a
resize left or resize right icon.  In this state, if you drag the end
of the effect, it performs an edit just like dragging the end of a
track does.

<p>The three editing behaviors of track trimming apply to effect trimming
and they are bound to the mouse buttons that you set in <em>interface
preferences</em>. See <a href="#INTERFACE">INTERFACE</a>.  When you perform a trim edit on an
effect, the effect boundary is moved by dragging on it.  Unlike track
editing, the effect has no source length.  You can extend the end of an
effect as much as desired without being limited.

<p>Also unlike track editing, the starting position of the drag operation
doesn't bind the edit decision to media.  The media the effect is bound
to doesn't follow effect edits.  Other effects; however, do follow
editing decisions made on an effect.  If you drag the end of an effect
which is lined up to effects on other tracks, the effects on the other
tracks will be edited while the media stays the same.

<p>What happens if you trim the end of an effect in, leaving a lot of
unaffected time near the end of the track?  When you drag an effect in
from the Resource Window you can insert the effect in the portion of
the row unoccupied by the trimming operation.  Realtime effects are
organized into rows under the track.  Each row can have multiple
effects.

<p>In addition to trimming, you can move effects up or down.  Every track
can have a stack of effects under it.  By moving an effect up or down
you change the order in which effects are processed in the stack.  Go
to an effect and right click to bring up the effect menu.  The
<em>Move up</em> and <em>Move down</em> options move the effect up or down.

<p>When you're moving effects up or down, be aware that if they're shared
as <em>shared effects</em>, any references will be pointing to a
different effect after the move operation.

<p>Finally, there's dragging of effects.  Dragging effects works just like
dragging edits.  You must select the <img src="arrow.png" alt="arrow.png"> arrow to enter drag and
drop mode before dragging effects.  The effects snap to media
boundaries, effect boundaries, and tracks.  Be aware if you drag a
reference to a shared effect, the reference will usually point to the
wrong effect afterwards.

<p>Right click on an effect to bring up a menu for the effect.  Select
<em>attach...</em> to change the effect or change the reference if it is
a shared effect.

<p><hr>
Node:<a name="RENDERED%20EFFECTS">RENDERED EFFECTS</a>,
Next:<a rel=next href="#TRANSITIONS">TRANSITIONS</a>,
Previous:<a rel=previous href="#REALTIME%20EFFECTS">REALTIME EFFECTS</a>,
Up:<a rel=up href="#USING%20EFFECTS">USING EFFECTS</a>
<br>

<h2>RENDERED EFFECTS</h2>

<p>Another type of effect is performed on a section of the track and the
result stored somewhere before it is played back.  The result is
usually pasted into the track to replace the original data.

<p>The rendered effects are not listed in the resource window but instead
are accessed through the <em>Audio-&gt;Render effect</em> and
<em>Video-&gt;Render effect</em> menu options.  Each of these menu options
brings up a dialog for the rendered effect.  Rendered effects apply to
only one type of track, either audio or video.  If no tracks of the
type exist, an error pops up.

<p>A region of the timeline to apply the effect to must be defined before
selecting <em>Render effect...</em>.  If no in/out points and no
highlighted region exists, the entire region after the insertion point
is treated as the affected region.  Otherwise, the region between the
in/out points or the highlighted region is the affected region.

<p>In the render effect dialog is a list of all the realtime and all the
rendered effects.  The difference here is that the realtime effects are
rendered to disk and not applied under the track.  Highlight an effect
in the list to designate it as the one being performed.

<p>Define a file to render the effect to in the <em>Select a file to
render to</em> box.  The <img src="magnify.png" alt="magnify.png"> magnifying glass allows file
selection from a list.

<p>Select a file format which can handle the track type.  The
<img src="wrench.png" alt="wrench.png"> wrench allows configuration specific to the file format.

<p>There is also an option for creating a new file at each label.  If you
have a CD rip on the timeline which you want to divide into different
files, the labels would become dividing points between the files if
this option were selected.  When the timeline is divided by labels, the
effect is re-initialized at every label.  Normalize operations take the
peak in the current file and not in the entire timeline.

<p>Finally there is an insertion strategy just like in the render dialog. 
It should be noted that even though the effect applies only to audio or
video, the insertion strategy applies to all tracks just like a
clipboard operation.

<p>When you click <em>OK</em> in the effect dialog, it calls the GUI of the
effect.  If the effect is also a realtime effect, a second GUI appears
to prompt for acceptance or rejection of the current settings.  After
accepting the settings, the effect is processed.

<p><hr>
Node:<a name="TRANSITIONS">TRANSITIONS</a>,
Previous:<a rel=previous href="#RENDERED%20EFFECTS">RENDERED EFFECTS</a>,
Up:<a rel=up href="#USING%20EFFECTS">USING EFFECTS</a>
<br>

<h2>TRANSITIONS</h2>

<p>When one edit ends and another edit begins, the default behaviour is to
have the first edit's output immediately become the output of the
second edit when played back.  Transitions are a way for the first
edit's output to become the second edit's output with different
variations.

<p>Cinelerra supports audio and video transitions, all of which are listed
in the resource window.  Transitions may only apply to the matching
track type.  Transitions under <em>audio transitions</em> can only apply
to audio tracks.  Transitions under <em>video transitions</em> can only
apply to video tracks.

<p>Load a video file and cut a section from the center so the edit point
is visible on the timeline.  Go the resource window and click on the
<em>Video transitions</em> folder.  Drag a transition from the transition
list onto the second video edit on the timeline.  A box highlights over
where the transition will appear.  Releasing it over the second edit
applies the transition between the first and second edit.

<p>You can now scrub over the transition with the transport controls and
watch the output in the <em>Compositor window</em>.  Scrubbing with the
insertion point doesn't normally show transitions because the
transition durations are usually too short.  The exact point in time
when the transition takes effect isn't straightforward.  It starts when
the second edit begins and lasts a certain amount of time into the
second edit.  Therefore, the first asset needs to have enough data
after the edit point to fill the transition into the second edit.

<p>Once the transition is in place, it can be edited similarly to an
effect.  Move the pointer over the transition and right click to bring
up the transition menu.  The <em>show</em> option brings up specific
parameters for the transition in question if there are any.  The
<em>length</em> option adjusts the length of the transition in seconds. 
Once these two parameters are set, they are applied to future
transitions until they are changed again.  Finally, the <em>detach</em>
option removes the transition from the timeline.

<p>Dragging and dropping transitions from the Resource window to the
Program window can be really slow and tiring.  Fortunately, once you
drag a transition from the Resource window, the <em>U</em> and <em>u</em>
keys will paste the same transition.  The <em>U</em> key pastes the last
video transition and the <em>u</em> key pastes the last audio transition
on all the recordable tracks.  If the insertion point or in point is
over an edit, the beginning of the edit is covered by the transition.

<p>It should be noted that when playing transitions from the timeline to a
hardware accelerated video device, the hardware acceleration will
usually be turned off momentarily during the transition and on after
the transition in order to render the transition.  Using an
unaccelerated video device for the entire timeline normally removes the
disturbance.

<p><hr>
Node:<a name="SETTING%20PROJECT%20ATTRIBUTES">SETTING PROJECT ATTRIBUTES</a>,
Next:<a rel=next href="#COMPOSITING">COMPOSITING</a>,
Previous:<a rel=previous href="#USING%20EFFECTS">USING EFFECTS</a>,
Up:<a rel=up href="#Top">Top</a>
<br>

<h1>SETTING PROJECT ATTRIBUTES</h1>

<p>When you play media files in Cinelerra, the media files have a certain
number of tracks, a certain frame size, a certain sample size, and so
on and so forth.  No matter what the media file has; however, it is
still played back according to the project attributes.  If an audio
file's samplerate is different than the project attributes, it is
resampled.  If a video file's frame size is different than the project
attributes, it is composited on a black frame, either cropped or
bordered with black.

<p>The project attributes are adjusted in <em>settings-&gt;format</em> and in
to a more limited extent in <em>file-&gt;new</em>.  When you adjust project
settings in <em>file-&gt;new</em> a new timeline is created with no data. 
Every timeline created from this point uses the same settings.  When
you adjust settings in <em>settings-&gt;format</em>, the timeline is not
recreated with no data but every timeline created from this point uses
the same settings.

<p>In addition to the traditional settings for sample rate, frame rate,
frame size, Cinelerra uses some unusual settings like <em>channel
positions, color model, and aspect ratio.</em>

<ul>

<li>
Channel positions is the only setting which doesn't affect the output
necessarily.  Click on a speaker icon and drag to change the position
of a channel.  It is merely a convenience so when more than 2 channels
are used, the pan controls on the timeline are effective.  Channels 3,
4, and 5 wouldn't be very adjustible if they occupied the same
locations as channels 1 and 2 on a pan control.  Normally a 6 channel
configuration would look like this:

<br><p>
<br><p>
<img src="channelpositions.png" alt="channelpositions.png">

<br><p>
<br><p>
<p>But different channels can be positioned very close together to make
them have the same output.

</p><li>
Color model is very important for video playback.  The video is stored
on disk in one colormodel, normally compressed using a YUV derivative. 
When played back, Cinelerra decompresses it from the file format
directly into the format of the output device.  If effects are
processed, the decompression is into an internal colormodel first and
the internal colormodel is then converted to the format of the output
device.  The selection of internal colormodel determines how accurate
and fast the effects are.

<p>Cinelerra colormodels are described using a certain packing order of
components and a certain number of bits for each component.  The
packing order is printed on the left and the bit allocation is printed
on the right.

<p><em>RGBA8888</em> uses red, green, blue, and alpha with 8 bits per
channel.

<p>In order to do effects which involve alpha channels, a colormodel with
an alpha channel must be selected.  These are RGBA8888, YUVA8888,
RGBA16161616, YUVA16161616.  The 4 channel colormodels are notoriously
slower than 3 channel colormodels, with the slowest being
RGBA16161616.  Some effects, like fade, work around the need for alpha
channels while other effects, like chromakey, require an alpha channel
to do anything, so it's a good idea to try the effect without alpha
channels.

<p>The YUV colormodels are usually faster than RGB colormodels when using
compressed footage.  They also destroy fewer colors than RGB
colormodels.  If footage stored as JPEG or MPEG is processed many times
in RGB, the colors will fade while they won't if processed in YUV.

</p><li>
Aspect ratio determines the shape of the video output when using the
X11 video output.  The numbers in each direction can be any floating
point number.  When drawn on the screen, video pixels are stretched to
match the aspect ratio.

</ul>

<p><hr>
Node:<a name="COMPOSITING">COMPOSITING</a>,
Next:<a rel=next href="#KEYFRAMES">KEYFRAMES</a>,
Previous:<a rel=previous href="#SETTING%20PROJECT%20ATTRIBUTES">SETTING PROJECT ATTRIBUTES</a>,
Up:<a rel=up href="#Top">Top</a>
<br>

<h1>COMPOSITING</h1>

<p>A large amount of Cinelerra's binary size is directed towards
compositing.  When you remove the letterboxing from a widescreen show,
you're compositing.  Changing the resolution of a show, making a split
screen, and fading in and out among other things are all compositing
operations in Cinelerra.  Cinelerra detects when it's in a compositing
operation and plays back through the compositing engine only then. 
Otherwise, it uses the fastest decoder available in the hardware.

<p>Compositing operations are done on the timeline and in the Compositor
window.  Shortcuts exist in the Resource window for changing project
attributes.  Once some video files are on the timeline, the compositor
window is a good place to try compositing.

<ul>
<li><a href="#THE%20CAMERA%20AND%20PROJECTOR">THE CAMERA AND PROJECTOR</a>: 
<li><a href="#MASKS">MASKS</a>: 
<li><a href="#CROPPING">CROPPING</a>: 
<li><a href="#SAFE%20REGIONS">SAFE REGIONS</a>: 
<li><a href="#OVERLAY%20MODES">OVERLAY MODES</a>: 
<li><a href="#TRACK%20AND%20OUTPUT%20SIZES">TRACK AND OUTPUT SIZES</a>: 
</ul>

<p><hr>
Node:<a name="THE%20CAMERA%20AND%20PROJECTOR">THE CAMERA AND PROJECTOR</a>,
Next:<a rel=next href="#MASKS">MASKS</a>,
Up:<a rel=up href="#COMPOSITING">COMPOSITING</a>
<br>

<h2>THE CAMERA AND PROJECTOR</h2>

<p>In the compositor window, the most important functions are the
<img src="camera.png" alt="camera.png"> camera button and the <img src="projector.png" alt="projector.png"> projector
button.  These control operation of the camera and projector.  Inside
Cinelerra's compositing pipeline, the camera determines where in the
source video the temporary is copied from.  The projector determines
where in the output the temporary is copied to.  The temporary is a
frame of video in Cinelerra's memory where all graphics processing is
done.  Each track has a different temporary which is defined by the
track size.  By resizing the tracks you can create splitscreens, pans,
and zooms.

<br><p>
<br><p>
<img src="compositing_pipeline.png" alt="compositing_pipeline.png">

<br><p>
<br><p>
<p><em>Visual representation of the compositing pipeline</em>.

<p>When editing the camera and projector in the compositing window, the
first track with <em>record</em> enabled is the track affected.  Even if
the track is completely transparent, it's still the affected track.  If
multiple video tracks exist, the easiest way to select one track for
editing is to <em>shift-click</em> on the record icon of the track.  This
solos the track.

<p>When the <em>projector</em> button is enabled in the compositor window,
you're in projector editing mode.  A guide box appears in the video
window.  Dragging anywhere in the video window causes the guide box to
move, hopefully along with the video.  <em>shift-dragging</em> anywhere
in the video window causes the guide box to shrink and grow along with
the video.  Once you've positioned the video with the projector, you're
ready to master the camera.

<p>Select the <img src="camera.png" alt="camera.png"> camera button to enable camera editing mode. 
In this mode, the guide box shows where the camera position is in
relation to past and future camera positions but not where it is in
relation to the source video.  Dragging the camera box in the
compositor window doesn't move the box but instead moves the location
of the video inside the box.

<p>For example, when you drag the camera left, the video moves right. 
When you drag the camera up, the video moves down.  When you shift-drag
the camera, the effect is the same as if you zoomed in or out of the
source.  The intention of the camera is to produce still photo panning,
while the intention of the projector is to composite several sources in
the same scene.

<p>In the compositing window, there is a popup menu of options for the
camera and projector.  Right click over the video portion of the
compositing window to bring up the menu.

<ul>

<li>Reset Camera causes the camera to return to the center position.

<li>Reset Projector causes the projector to return to the center.

</ul>

<p>The camera and projector have shortcut operations neither in the popup
menu or represented in video overlays.  These are accessed in the
<em>Tool window</em>.  Most operations in the Compositor window have a
tool window which is enabled by activating the <img src="toolwindow.png" alt="toolwindow.png">
question mark.

<p>In the case of the camera and projector, the tool window shows x, y,
and z coordinates.  By either tumbling or entering text directly, the
camera and projector can be precisely positioned.  9 justification
types are also defined for easy access.  A popular justification
operation is upper left projection after image reduction.  This is used
when reducing the size of video with aspect ratio adjustment.

<p>The translation effect allows simultaneous aspect ratio conversion and
reduction but is easier to use if the reduced video is put in the upper
left of the temporary instead of in the center.  The track size is set
to the original size of the video and the camera is centered.  The
output size is set to the reduced size of the video.  Without any
effects, this produces just the cropped center portion of the video in
the output.

<p>The translation effect is dropped onto the video track.  The input
dimensions of the translation effect are set to the original size and
the output dimensions are set to the reduced size.  To put the reduced
video in the center section that the projector shows would require
offsetting <em>out x and out y</em> by a complicated calculation. 
Instead, we leave <em>out x and out y</em> at 0 and use the projector's
tool window.

<p>Merely by selecting <img src="left_justify.png" alt="left_justify.png"> left justify and
<img src="top_justify.png" alt="top_justify.png"> top justify, the projector displays the reduced
image from the top left corner of the temporary in the center of the
output.

<p><hr>
Node:<a name="MASKS">MASKS</a>,
Next:<a rel=next href="#CROPPING">CROPPING</a>,
Previous:<a rel=previous href="#THE%20CAMERA%20AND%20PROJECTOR">THE CAMERA AND PROJECTOR</a>,
Up:<a rel=up href="#COMPOSITING">COMPOSITING</a>
<br>

<h2>MASKS</h2>

<p>Masks select a region of the video for either displaying or hiding. 
Masks are also used in conjunction with another effect to isolate the
effect to a certain region of the frame.  A copy of one video track may
be delayed slightly and unmasked in locations where the one copy has
interference but the other copy doesn't.  Color correction may be
needed in one section of a frame but not another.  A mask can be
applied to just a section of the color corrected track while the
vanilla track shows through.  Removal of boom microphones, airplanes,
and housewives are other mask uses.

<p>The order of the compositing pipeline affects what can be done with
masks.  Mainly, masks are performed on the temporary after effects and
before the projector.  This means multiple tracks can be bounced to a
masked track and projected with the same mask.

<p>Our compositing pipeline graph now has a masking stage.  There are 8
possible masks per track.  Each mask is defined separately, although
they each perform the same operation, whether it's addition or
subtraction.

<br><p>
<br><p>
<img src="compositing_pipeline2.png" alt="compositing_pipeline2.png">

<br><p>
<br><p>
<p><em>Compositing pipeline with masks</em>

<p>To define a mask, go into the Compositor window and enable the
<img src="mask.png" alt="mask.png"> <em>mask</em> toggle.  Now go over the video and
click-drag.  Click-drag again in another part of the image to create
each new point of the mask.  While it isn't the conventional bezier
curve behavior, this masking interface performs in realtime what the
effect of the mask is going to be.  Creating each point of the mask
expands a rubber band curve.

<p>Once points are defined, they can be moved by <em>ctrl-dragging</em> in
the vicinity of the corner.  This; however, doesn't smooth out the
curve.  The in-out points of the bezier curve are accessed by
<em>shift-dragging</em> in the vicinity of the corner.  Then
<em>shift-dragging</em> near the in or out point causes the point to
move.

<p>Finally, once you have a mask, the mask can be translated in one piece
by <em>alt-dragging</em> the mask.  Mask editing in Cinelerra is
identical to how The Gimp edits masks except in this case the effect of
the mask is always on.

<p>The masks have many more parameters which couldn't be represented with
video overlays.  These are represented in the tool window for masks. 
Selecting the <img src="toolwindow.png" alt="toolwindow.png"> question mark when the <img src="mask.png" alt="mask.png">
mask toggle is highlighted brings up the mask options.

<p>The <em>mode</em> of the mask determines if the mask removes data or
makes data visible.  If the mode is subtractive, the mask causes video
to disappear.  If the mode is additive, the mask causes video to appear
and everything outside the mask to disappear.

<p>The <em>value</em> of the mask determines how extreme the addition or
subtraction is.  In the subtractive mode, higher values subtract more
alpha.  In the additive mode, higher values make the region in the mask
brighter while the region outside the mask is always hidden.

<p>The mask number determines which one of the 8 possible masks we're
editing.  Each track has 8 possible masks.  When you click-drag in the
compositor window, you're only editing one of the masks.  Change the
value of <em>mask number</em> to cause another mask to be edited.  The
previous mask is still active but only the curve overlay for the
currently selected mask is visible.

<p>When multiple masks are used, their effects are ORed together.  Every
mask in a single track uses the same value and mode.

<p>The edges of a mask are hard by default but this rarely is desired. 
The <em>feather</em> parameter determines how many pixels to feather the
mask.  This creates softer edges but takes longer to render.

<p>Finally, there are parameters which affect one point on the current
mask instead of the whole mask.  These are <em>Delete, x, y</em>.  The
active point is defined as the last point dragged in the compositor
window.  Any point can be activated merely by <em>ctrl-clicking</em> near
it without moving the pointer.  Once a point is activated,
<em>Delete</em> deletes it and <em>x, y</em> allow repositioning by numeric
entry.

<p><hr>
Node:<a name="CROPPING">CROPPING</a>,
Next:<a rel=next href="#SAFE%20REGIONS">SAFE REGIONS</a>,
Previous:<a rel=previous href="#MASKS">MASKS</a>,
Up:<a rel=up href="#COMPOSITING">COMPOSITING</a>
<br>

<h2>CROPPING</h2>

<p>Cropping changes the value of the output dimensions and the projector
to reduce the visible picture area.  Enable the <img src="crop.png" alt="crop.png"> crop
toggle and the <img src="toolwindow.png" alt="toolwindow.png"> tool window to perform cropping in
the compositing window.  This draws a rectangle over the video. 
Click-drag anywhere in the video to create a new rectangle.  Click-drag
over any corner of the rectangle to reposition the corner.  The tool
window allows text entry of the coordinates.  When the rectangle is
positioned, hit the <em>do it</em> button in the tool window.

<p><hr>
Node:<a name="SAFE%20REGIONS">SAFE REGIONS</a>,
Next:<a rel=next href="#OVERLAY%20MODES">OVERLAY MODES</a>,
Previous:<a rel=previous href="#CROPPING">CROPPING</a>,
Up:<a rel=up href="#COMPOSITING">COMPOSITING</a>
<br>

<h2>SAFE REGIONS</h2>

<p>On consumer displays the borders of the image are cut off and within
the cutoff point is a region which isn't always square like it is in
the compositor window.  The borders are intended for scratch room and
vertical blanking data.  You can show where these borders are by
enabling the <img src="titlesafe.png" alt="titlesafe.png"> safe regions toggle.  Keep titles inside
the inner rectangle and keep action inside the outer rectangle.

<p><hr>
Node:<a name="OVERLAY%20MODES">OVERLAY MODES</a>,
Next:<a rel=next href="#TRACK%20AND%20OUTPUT%20SIZES">TRACK AND OUTPUT SIZES</a>,
Previous:<a rel=previous href="#SAFE%20REGIONS">SAFE REGIONS</a>,
Up:<a rel=up href="#COMPOSITING">COMPOSITING</a>
<br>

<h2>OVERLAY MODES</h2>

<p>Every track has an overlay mode, accessible by expanding the track. 
Select the <img src="expandpatch_checked.png" alt="expandpatch_checked.png"> expand track toggle to view all
the options for a video track.  The overlay mode of the track is
<em>normal</em> by default.  Select other modes by selecting the
<em>normal</em> button.  Overlay modes are processed inside the projector
stage of compositing.  The different modes are summarized below.

<ul>

<li>
Normal uses a traditional Porter-Diff equation to blend tracks with
alpha.  When no alpha exists, the new track replaces the output.

<li>
In addition, whatever is in the output is added to the current track. 
The result is blended based on the current track's alpha onto the
output.

<li>
In subtraction, the current track is subtracted from the output and the
result is alpha blended onto the output.

<li>
Multiply is the most useful operation.  The current track is multiplied
by the output and the result blended onto the output.  Usually a black
and white image with no alpha channel or a white title on a black image
is used as the current track.  With the multiply operation, only the
output portions under the white area show.

<li>
Divide divides the current track by the output and the result is
blended into the output.  It usually results in overloaded levels.

<li>
Replace does no blending and overwrites the output with the current
track.

</ul>

<p><hr>
Node:<a name="TRACK%20AND%20OUTPUT%20SIZES">TRACK AND OUTPUT SIZES</a>,
Previous:<a rel=previous href="#OVERLAY%20MODES">OVERLAY MODES</a>,
Up:<a rel=up href="#COMPOSITING">COMPOSITING</a>
<br>

<h2>TRACK AND OUTPUT SIZES</h2>

<p>The size of the temporary and the size of the output in our compositing
pipeline are independant and variable.  This fits into everything
covered so far.  The camera's viewport is the temporary size.  Effects
are processed in the temporary and are affected by the temporary size. 
Projectors are rendered to the output and are affected by the output
size.  If the temporary is smaller than the output, the temporary is
bordered by blank regions in the output.  If the temporary is bigger
than the output, the temporary is cropped.

<p>The temporary size is defined as the track size.  Each track has a
different size.  Right click on a track to bring up the track's menu. 
Select <em>Resize Track</em> to resize the track to any arbitrary size. 
Alternatively you can select <em>Match output size</em> to make the track
the same size as the output.

<p>The output size is set in either <em>New</em> when creating a new project
or <em>Settings-&gt;Format</em>.  In the Resource window there is another
way to change the output size.  Right click on a video asset and select
<em>Match project size</em> to conform the output to the asset.  When new
tracks are created, the track size always conforms to the output size
specified by these methods.

<p><hr>
Node:<a name="KEYFRAMES">KEYFRAMES</a>,
Next:<a rel=next href="#CAPTURING%20MEDIA">CAPTURING MEDIA</a>,
Previous:<a rel=previous href="#COMPOSITING">COMPOSITING</a>,
Up:<a rel=up href="#Top">Top</a>
<br>

<h1>KEYFRAMES</h1>

<p>Setting static compositing parameters isn't very useful most of the
time.  Normally you need to move the camera around over time or change
mask positions.  Masks need to follow objects.  We create dymanic
changes by defining keyframes.  A keyframe is a certain point in time
when the settings for one operation change.  In Cinelerra, there are
keyframes for almost every compositing parameter and effect parameter.

<p>Whenever you adjust any parameter, the value is stored in a keyframe. 
If the value is stored in a keyframe, why doesn't it always change? 
The keyframe it is stored in is known as the <em>default keyframe</em>. 
The default keyframe applies to the entire duration if no other
keyframes are present.  The default keyframe is not drawn anywhere
because it always exists.  The only way change occurs over time is if
non-default keyframes are created.

<p>Display keyframes for any parameter by using the <em>view</em> menu. 
When keyframes are selected, they are drawn on the timeline over the
tracks they apply to.

<ul>
<li><a href="#CURVE%20KEYFRAMES">CURVE KEYFRAMES</a>: 
<li><a href="#TOGGLE%20KEYFRAMES">TOGGLE KEYFRAMES</a>: 
<li><a href="#AUTOMATIC%20KEYFRAMES">AUTOMATIC KEYFRAMES</a>: 
<li><a href="#COMPOSITOR%20KEYFRAMES">COMPOSITOR KEYFRAMES</a>: 
<li><a href="#EDITING%20KEYFRAMES">EDITING KEYFRAMES</a>: 
</ul>

<p><hr>
Node:<a name="CURVE%20KEYFRAMES">CURVE KEYFRAMES</a>,
Next:<a rel=next href="#TOGGLE%20KEYFRAMES">TOGGLE KEYFRAMES</a>,
Up:<a rel=up href="#KEYFRAMES">KEYFRAMES</a>
<br>

<h2>CURVE KEYFRAMES</h2>

<p>Fade and zoom settings are stored in bezier curves.  Go to
<em>view-&gt;fade keyframes</em> or <em>view-&gt;...zoom</em> to show curves on
the timeline.  It's sometimes easier to pull down the <em>view</em> menu
and then use the keyboard shortcuts listed in the menu to enable or
disable keyframes while the menu is visible.  In either arrow editing
mode or i-beam editing mode, move the cursor over the curves in the
timeline until it changes shape.  Then merely by clicking and dragging
on the curve you can create a keyframe at the position.

<p>After the keyframe is created, click drag on it again to reposition
it.  When you click-drag a second keyframe on the curve, it creates a
smooth ramp.  <em>ctrl-dragging</em> on a keyframe changes the value of
either the input control or the output control.  This affects the
sharpness of the curve.  While the input control and the output control
can be moved horizontally as well as vertically, the horizontal
movement is purely for legibility and isn't used in the curve value.

<p>You may remember that The Gimp and the Compositing masks all use
<em>shift</em> to select control points so why does the timeline use
<em>ctrl</em>?  When you <em>shift-drag</em> on a timeline curve, the
keyframe jumps to the value of either the next or previous keyframe,
depending on which exists.  This lets you set a constant curve value
without having to copy the next or previous keyframe.

<p><hr>
Node:<a name="TOGGLE%20KEYFRAMES">TOGGLE KEYFRAMES</a>,
Next:<a rel=next href="#AUTOMATIC%20KEYFRAMES">AUTOMATIC KEYFRAMES</a>,
Previous:<a rel=previous href="#CURVE%20KEYFRAMES">CURVE KEYFRAMES</a>,
Up:<a rel=up href="#KEYFRAMES">KEYFRAMES</a>
<br>

<h2>TOGGLE KEYFRAMES</h2>

<p>Play and mute are stored in toggle keyframes.  Playback keyframes
determine where the track is playable and are rarely used.  Mute
keyframes are probably more often used.  They determine where the track
is processed but not rendered to the output.  Click-drag on these
curves to create a keyframe.  Unlike curves, the toggle keyframe has
only two values: on or off.  Ctrl and shift do nothing on toggle
keyframes.

<p><hr>
Node:<a name="AUTOMATIC%20KEYFRAMES">AUTOMATIC KEYFRAMES</a>,
Next:<a rel=next href="#COMPOSITOR%20KEYFRAMES">COMPOSITOR KEYFRAMES</a>,
Previous:<a rel=previous href="#TOGGLE%20KEYFRAMES">TOGGLE KEYFRAMES</a>,
Up:<a rel=up href="#KEYFRAMES">KEYFRAMES</a>
<br>

<h2>AUTOMATIC KEYFRAMES</h2>

<p>You may have noticed when a few fade curves are set up, moving the
insertion point around the curves causes the faders to reflect the
curve value under the insertion point.  This isn't just to look cool. 
The faders themselves can set keyframes in automatic keyframe mode. 
Automatic keyframe mode is usually more useful than dragging curves.

<p>Enable automatic keyframe mode by enabling the automatic keyframe
toggle <img src="autokeyframe.png" alt="autokeyframe.png">.  In automatic keyframe mode, every time
you tweek a keyframeable parameter it creates a keyframe on the
timeline.  Since automatic keyframes affect many parameters, it's best
enabled just before you need a keyframe and disabled immediately
thereafter.

<p>It's useful to go into the <em>View</em> menu and make the desired
parameter visible before performing a change.  The location where the
automatic keyframe is generated is under the insertion point.  If the
timeline is playing back during a tweek, several automatic keyframes
will be generated as you change the parameter.

<p>When automatic keyframe mode is disabled, a similarly strange thing
happens.  Adjusting a parameter adjusts the keyframe immediately
preceeding the insertion point.  If two fade keyframes exist and the
insertion point is between them, changing the fader changes the first
keyframe.

<p>There are many parameters which can only be keyframed in automatic
keyframe mode.  These are parameters for which curves would take up too
much space on the track or which can't be represented easily by a
curve.

<p>Effects are only keyframable in automatic mode because of the number of
parameters in each individual effect.

<p>Camera and projector translation can only be keyframed in automatic
keyframe mode while camera and projector zoom can be keyframed with
curves.  It is here that we conclude the discussion of compositing,
since compositing is highly dependant on the ability to change over
time.

<p><hr>
Node:<a name="COMPOSITOR%20KEYFRAMES">COMPOSITOR KEYFRAMES</a>,
Next:<a rel=next href="#EDITING%20KEYFRAMES">EDITING KEYFRAMES</a>,
Previous:<a rel=previous href="#AUTOMATIC%20KEYFRAMES">AUTOMATIC KEYFRAMES</a>,
Up:<a rel=up href="#KEYFRAMES">KEYFRAMES</a>
<br>

<h2>COMPOSITOR KEYFRAMES</h2>

<p>Camera and projector translation is represented by two parameters: x
and y.  Therefore it is cumbersome to adjust with curves.  Cinelerra
solves this problem by relying on automatic keyframes.  With a video
track loaded, move the insertion point to the beginning of the track
and enable automatic keyframe mode.

<p>Move the projector slightly in the compositor window to create a
keyframe.  Then go forward several seconds.  Move the projector a long
distance to create another keyframe and emphasize motion.  This creates
a second projector box in the compositor, with a line joining the two
boxes.  The joining line is the motion path.  If you create more
keyframes, more boxes are created.  Once all the desired keyframes are
created, disable automatic keyframe mode.

<p>Now when scrubbing around with the compositor window's slider, the
video projection moves over time.  At any point between two keyframes,
the motion path is read for all time before the insertion point and
green for all time after the insertion point.  It's debatable if this
is a very useful feature but it makes you feel good to know what
keyframe is going to be affected by the next projector tweek.

<p>Click-drag when automatic keyframes are off to adjust the preceeding
keyframe.  If you're halfway between two keyframes, the first projector
box is adjusted while the second one stays the same.  Furthermore, the
video doesn't appear to move in step with the first keyframe.  This is
because, halfway between two keyframes the projector translation is
interpolated.  In order to set the second keyframe you'll need to scrub
after the second keyframe.

<p>By default the motion path is a straight line, but it can be curved
with control points.  <em>Ctrl-drag</em> to set either the in or out
control point of the preceeding keyframe.  Once again, we depart from
The Gimp because <em>shift</em> is already used for zoom.  After the in
or out control points are extrapolated from the keyframe,
<em>Ctrl-dragging</em> anywhere in the video adjusts the nearest control
point.  A control point can be out of view entirely yet still
controllable.

<p>When editing the camera translation, the behavior of the camera boxes
is slightly different.  Camera automation is normally used for still
photo panning.  The current camera box doesn't move during a drag, but
if multiple keyframes are set, every camera box except the current
keyframe appears to move.  This is because the camera display shows
every other camera position relative to the current one.

<p>The situation becomes more intuitive if you bend the motion path
between two keyframes and scrub between the two keyframes.  The
division between red and green, the current position between the
keyframes, is always centered while the camera boxes move.

<p><hr>
Node:<a name="EDITING%20KEYFRAMES">EDITING KEYFRAMES</a>,
Previous:<a rel=previous href="#COMPOSITOR%20KEYFRAMES">COMPOSITOR KEYFRAMES</a>,
Up:<a rel=up href="#KEYFRAMES">KEYFRAMES</a>
<br>

<h2>EDITING KEYFRAMES</h2>

<p>Keyframes can be shifted around and moved between tracks on the
timeline using similar cut and paste operations to editing media.  Only
the keyframes selected in the <em>view</em> menu are affected by keyframe
editing operations, however.

<p>The most popular keyframe editing operation is replication of some
curve from one track to the other, to make a stereo pair.  The first
step is to solo the source track's record <img src="recordpatch_up.png" alt="recordpatch_up.png"> patch
by <em>shift-clicking</em> on it.  Then either set in/out points or
highlight the desired region of keyframes.  Go to <em>keyframes-&gt;copy
keyframes</em> to copy them to the clipboard.  Solo the destination track's
record <img src="recordpatch_up.png" alt="recordpatch_up.png"> patch by <em>shift-clicking</em> on it and
go to <em>keyframes-&gt;paste keyframes</em> to paste the clipboard.

<p>The media editing commands are mapped to the keyframe editing commands
by using the <em>shift</em> key instead of just the keyboard shortcut.

<p>This leads to the most complicated part of keyframe editing, the
default keyframe.  Remember that when no keyframes are set at all,
there is still a default keyframe which stores a global parameter for
the entire duration.  The default keyframe isn't drawn because it
always exists.  What if the default keyframe is a good value which you
want to transpose between other non-default keyframes?  The
<em>keyframes-&gt;copy default keyframe</em> and <em>keyframes-&gt;paste
default keyframe</em> allow conversion of the default keyframe to a
non-default keyframe.

<p><em>Keyframes-&gt;copy default keyframe</em> copies the default keyframe to
the clipboard, no matter what region of the timeline is selected.  The
<em>keyframes-&gt;paste keyframes</em> function may then be used to paste
the clipboard as a non-default keyframe.

<p>If you've copied a non-default keyframe, it can be stored as the
default keyframe by calling <em>keyframes-&gt;paste default keyframe</em>. 
After using paste default keyframe to convert a non-default keyframe
into a default keyframe, you won't see the value of the default
keyframe reflected until all the non-default keyframes are removed.

<p>Finally, there is a convenient way to delete keyframes besides
selecting a region and calling <em>keyframes-&gt;clear keyframes</em>. 
Merely click-drag a keyframe before its preceeding keyframe or after
its following keyframe on the track.

<p><hr>
Node:<a name="CAPTURING%20MEDIA">CAPTURING MEDIA</a>,
Next:<a rel=next href="#EFFECT%20DESCRIPTIONS">EFFECT DESCRIPTIONS</a>,
Previous:<a rel=previous href="#KEYFRAMES">KEYFRAMES</a>,
Up:<a rel=up href="#Top">Top</a>
<br>

<h1>CAPTURING MEDIA</h1>

<p>Ideally, all media would be stored on hard drives, CD-ROM, flash, or
DVD and loading it into Cinelerra would be a matter of loading a file. 
In reality, very few sources of media can be accessed like a filesystem
but instead rely on tape transport mechanisms and dumb I/O mechanisms
to transfer the data to computers.  These media types are imported into
Cinelerra through the Record dialog.

<p>The first step in recording is to configure the input device.  In
<em>Settings-&gt;preferences</em> are a number of recording parameters
described in configuration See <a href="#RECORDING">RECORDING</a>.  These parameters apply to
recording no matter what the project settings are, because the
recording parameters are usually the maximum capability of the
recording hardware while project settings come and go.

<p>Go to <em>File-&gt;record</em> to record a dumb I/O source.  This prompts
for an output format much like rendering does.  Once that's done, the
record window and the record monitor pop up.

<p>The record window has discrete sections.  While many parameters change
depending on if the file has audio or video, the discrete sections are
always the same.

<ul>

<li>
The output format area describes the format of the output file and the
current position within it.

<li>
The edit batch area lets you change parameters in the current batch.

<li>
The transport controls start and stop recording different ways.

<li>
The batch list displays all the defined batches.

<li>
The confirmation area lets you determine how the output files are
imported into the timeline and quit.

</ul>

<img src="recording.png" alt="recording.png">

<br><p>
<br><p>
<p><em>Recording window areas</em>

<p>Recording in Cinelerra is organized around batches.  A batch
essentially defines a distinct output file for the recording.  For now
you can ignore the batch concept entirely and record merely by hitting
the record button <img src="record.png" alt="record.png">.

<p>The record button opens the current output file if it isn't opened and
writes captured data to it.  Use the stop button to stop the
recording.  Recording can be resumed with the record button without
erasing the file at this point.  In the case of a video file, there is
a single frame record button <img src="singleframe.png" alt="singleframe.png"> which records a single
frame.

<p>When enough media is recorded, choose an insertion method from the
<em>Insertion Strategy</em> menu and hit <em>close</em>.

<ul>
<li><a href="#BATCHES">BATCHES</a>: 
<li><a href="#EDITING%20TUNER%20INFORMATION">EDITING TUNER INFORMATION</a>: 
</ul>

<p><hr>
Node:<a name="BATCHES">BATCHES</a>,
Next:<a rel=next href="#EDITING%20TUNER%20INFORMATION">EDITING TUNER INFORMATION</a>,
Up:<a rel=up href="#CAPTURING%20MEDIA">CAPTURING MEDIA</a>
<br>

<h2>BATCHES</h2>

<p>Now we come to the concept of batches.  Batches try to make the dumb
I/O look more like a filesystem.  Batches are traditionally used to
divide tape into different programs and save the different programs as
different files instead of recording straight through an entire tape. 
Because of the high cost of developing frame-accurate deck control
mechanisms, the only use of batches now is recording different programs
during different times of day.  This is still useful for recording TV
shows or time lapse movies as anyone who can't afford proper appliances
knows.

<p>The record window supports a list of batches and two recording modes:
interactive and batch recording.  Interactive recording happens when
the record button is pressed.  Interactive recording starts immediately
and uses the current batch to determine everything except start time. 
By default, the current batch is configured to behave like tape.

<p>Batch recording happens when the <em>start</em> button is pressed.  In
batch recording, the <em>start time</em> is the time the batch starts
recording.

<p>First, you'll want to create some batches.  Each batch has certain
parameters and methods of adjustment.

<ul>

<li>
<em>On</em> determines whether the batch is included in batch recording
operations.  Click the list row under <em>On</em> to enable or disable
batches.

<li>
<em>Path</em> is the file the batch is going to be recorded to.  The
filename specified in the record dialog is the name of the first batch,
to simplify interactive recording, but the filename may be changed in
the record window for any batch in the <em>edit batch</em> area.

<li>
<em>News</em> shows whether the file exists or not.  This is a very
important attribute since there is no confirmation dialog if the file
exists.  The first time you hit record, the file is opened.  If the
file exists at this point it's erased.  News says <em>File exists</em> if
it exists and <em>OK</em> if it doesn't.  Every time you resume recording
in the same batch, the news should say <em>Open</em>, indicating the file
is already opened and won't be erased in the next record button press.

<p>If you change out of the current batch after recording, the file is
closed.  Next time you change into the batch, the file will be erased.

</p><li>
<em>Start time</em> is the 24 hour time of day the batch will start
recording if in batch mode.  The start time may become a time of tape
and reel number if deck control is implemented but for now it's a time
of day.

<li>
<em>Duration</em> is the length of the batch.  It only has meaning if the
<em>Mode</em> of the batch is <em>Timed</em>.  Once the recording length
reaches <em>duration</em> the recording stops, whether in interactive or
batch mode.

<li>
<em>Source</em> has meaning only when the capturing hardware has multiple
sources.  Usually the source is a tuner channel or input.  When the
current batch finishes and the next batch begins recording, the source
is changed to what the next batch is set to.  This way multiple TV
stations can be recorded at different times.

</ul>

<p>The record window has a notion of the <em>current batch</em>.  The
current batch is not the same as the batch which is highlighted in the
batch list.  The current batch text is colored red in the batch list. 
The highlighted batch is merely displayed in the edit batch section for
editing.

<p>By coloring the current batch red, any batch can be edited by
highlighting it, without changing the batch to be recorded.

<p>All recording operations take place in the current batch.   If there
are multiple batches, highlight the desired batch and hit
<em>activate</em> to make it the current batch.  If the <em>start</em>
button is pressed, the current batch flashes to indicate it's waiting
for the start time in batch mode.  If the <em>record</em> button is
pressed, the current batch is recorded immediately in interactive mode.

<p>In batch and interactive recording modes, when the current batch
finishes recording the next batch is activated and performed.  All
future recording is done in batch mode.  When the first batch finishes,
the next batch flashes until its start time is reached.

<p>Interrupt either the batch or the interactive operation by hitting the
stop button.

<p>Finally there is the <img src="rewind.png" alt="rewind.png"> rewind button.  In either
interactive or batch recording, the rewind button causes the current
batch to close its file.  The next recording operation in the current
batch deletes the file.

<p><hr>
Node:<a name="EDITING%20TUNER%20INFORMATION">EDITING TUNER INFORMATION</a>,
Previous:<a rel=previous href="#BATCHES">BATCHES</a>,
Up:<a rel=up href="#CAPTURING%20MEDIA">CAPTURING MEDIA</a>
<br>

<h2>EDITING TUNER INFORMATION</h2>

<p>Sometimes in the recording process and the configuration process,
you'll need to define and select tuner channels to either record or
play back to.  In the case of the Video4Linux recording driver, tuner
channels define the source.  In the case of the Buz playback driver,
tuner channels define the destination.

<p>Defining tuner channels is accomplished by pushing the <img src="channel.png" alt="channel.png">
channel button.  This brings up the channel editing window.  In this
window you add, edit, and sort channels.  Also, for certain video
drivers, you can adjust the picture quality.

<p>The <em>add</em> operation brings up a channel editing box.  The title of
the channel appears in the channel list.  The source of the channel is
the entry in the physical tuner's frequency table corresponding to the
title.

<p>Fine tuning in the channel edit dialog adjusts the physical frequency
slightly if the driver supports it.  The norm and frequency table
together define which frequency table is selected for defining
sources.  If the device supports multiple inputs, the input menu
selects these.

<p>To sort channels, highlight the channel in the list and push <em>move
up</em> or <em>move down</em> to move it.

<p>Once channels are defined, the <em>source</em> item in the record window
can be used to select channels for recording.  The same channel
selecting ability also exists in the record monitor window.  Be aware
channel selections in the record monitor window and the record window
are stored in the current batch.

<p><hr>
Node:<a name="EFFECT%20DESCRIPTIONS">EFFECT DESCRIPTIONS</a>,
Previous:<a rel=previous href="#CAPTURING%20MEDIA">CAPTURING MEDIA</a>,
Up:<a rel=up href="#Top">Top</a>
<br>

<h1>EFFECT DESCRIPTIONS</h1>

<p>Most effects in Cinelerra can be figured out just by using them and
tweeking.  Here are brief descriptions of effects which you might not
utilize fully by mere experimentation.

<ul>
<li><a href="#CHROMA%20KEY">CHROMA KEY</a>: 
</ul>

<p><hr>
Node:<a name="CHROMA%20KEY">CHROMA KEY</a>,
Up:<a rel=up href="#EFFECT%20DESCRIPTIONS">EFFECT DESCRIPTIONS</a>
<br>

<h2>CHROMA KEY</h2>

<p>This effect replaces the selected color or intensity with black if
there is no alpha channel and replaces it with transparency if there is
an alpha channel.  The selection of color model is important.

<p>Chroma key uses either the value or the hue to determine what is
erased.  If this parameter is within a certain threshold it's erased. 
It's not a simple on/off switch, however.  As the selected parameter
approaches the edge of the threshold, it gradually gets erased if the
slope is low or is completely erased if the slope is high.

<p>The slope tries to soften the edges of the chroma key but it doesn't
work well for compressed sources.  A popular softening technique is to
use a maximum slope and chain a blur effect below the chroma key effect
to blur just the alpha.

</body></html>

